//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for HealthResponseStatus.
const (
	Degraded  HealthResponseStatus = "degraded"
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for JobState.
const (
	Cancelled JobState = "cancelled"
	Completed JobState = "completed"
	Failed    JobState = "failed"
	Pending   JobState = "pending"
	Running   JobState = "running"
)

// Defines values for SchedulerInfoType.
const (
	Mock  SchedulerInfoType = "mock"
	Slurm SchedulerInfoType = "slurm"
)

// CreateJobRequest defines model for CreateJobRequest.
type CreateJobRequest struct {
	// Id Unique job identifier
	Id string `json:"id"`

	// Nodes List of node names to allocate
	Nodes []string `json:"nodes"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// User User who submitted the job
	User string `json:"user"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status Current health status of the service
	Status HealthResponseStatus `json:"status"`

	// Timestamp Time of health check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version *string `json:"version,omitempty"`
}

// HealthResponseStatus Current health status of the service
type HealthResponseStatus string

// Job defines model for Job.
type Job struct {
	// CpuUsage Current CPU usage percentage
	CpuUsage *float64 `json:"cpu_usage,omitempty"`

	// EndTime Job end time (if completed or failed)
	EndTime *time.Time `json:"end_time,omitempty"`

	// GpuUsage Current GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// Id Unique job identifier
	Id string `json:"id"`

	// MemoryUsageMb Current memory usage in megabytes
	MemoryUsageMb *int `json:"memory_usage_mb,omitempty"`

	// Nodes List of node names allocated to the job
	Nodes []string `json:"nodes"`

	// RuntimeSeconds Total runtime in seconds
	RuntimeSeconds *float64 `json:"runtime_seconds,omitempty"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// StartTime Job start time
	StartTime time.Time `json:"start_time"`

	// State Current state of the job
	State JobState `json:"state"`

	// User User who submitted the job
	User string `json:"user"`
}

// JobListResponse defines model for JobListResponse.
type JobListResponse struct {
	Jobs []Job `json:"jobs"`

	// Limit Maximum number of jobs returned
	Limit int `json:"limit"`

	// Offset Number of jobs skipped
	Offset int `json:"offset"`

	// Total Total number of jobs matching the filter
	Total int `json:"total"`
}

// JobMetricsResponse defines model for JobMetricsResponse.
type JobMetricsResponse struct {
	// JobId Job identifier
	JobId   string         `json:"job_id"`
	Samples []MetricSample `json:"samples"`

	// Total Total number of samples returned
	Total int `json:"total"`
}

// JobState Current state of the job
type JobState string

// MetricSample defines model for MetricSample.
type MetricSample struct {
	// CpuUsage CPU usage percentage at this point in time
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage at this point in time (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes at this point in time
	MemoryUsageMb int `json:"memory_usage_mb"`

	// Timestamp Time when the sample was recorded
	Timestamp time.Time `json:"timestamp"`
}

// RecordMetricsRequest defines model for RecordMetricsRequest.
type RecordMetricsRequest struct {
	// CpuUsage CPU usage percentage
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes
	MemoryUsageMb int `json:"memory_usage_mb"`
}

// SchedulerInfo Metadata from the external workload manager (e.g., SLURM).
// This information is populated when jobs are synced from an external scheduler.
type SchedulerInfo struct {
	// Account Account/project charged for the job
	Account *string `json:"account,omitempty"`

	// ExitCode Job exit code (available after completion)
	ExitCode *int `json:"exit_code,omitempty"`

	// ExternalJobId Job ID in the external scheduler (e.g., SLURM job_id)
	ExternalJobId *string `json:"external_job_id,omitempty"`

	// Extra Additional scheduler-specific metadata
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Partition Scheduler partition/queue name
	Partition *string `json:"partition,omitempty"`

	// Priority Job priority in the scheduler queue
	Priority *int `json:"priority,omitempty"`

	// Qos Quality of Service level
	Qos *string `json:"qos,omitempty"`

	// RawState Original state string from the scheduler before normalization.
	// For SLURM: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT, NODE_FAIL, etc.
	RawState *string `json:"raw_state,omitempty"`

	// SubmitTime Time when the job was submitted to the scheduler
	SubmitTime *time.Time `json:"submit_time,omitempty"`

	// Type Type of scheduler that manages this job
	Type *SchedulerInfoType `json:"type,omitempty"`
}

// SchedulerInfoType Type of scheduler that manages this job
type SchedulerInfoType string

// UpdateJobRequest defines model for UpdateJobRequest.
type UpdateJobRequest struct {
	CpuUsage      *float64 `json:"cpu_usage,omitempty"`
	GpuUsage      *float64 `json:"gpu_usage,omitempty"`
	MemoryUsageMb *int     `json:"memory_usage_mb,omitempty"`

	// State Current state of the job
	State *JobState `json:"state,omitempty"`
}

// JobId defines model for JobId.
type JobId = string

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// State Filter by job state
	State *JobState `form:"state,omitempty" json:"state,omitempty"`

	// User Filter by user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Node Filter by node name
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Limit Maximum number of jobs to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of jobs to skip for pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetJobMetricsParams defines parameters for GetJobMetrics.
type GetJobMetricsParams struct {
	// StartTime Start of time range (RFC3339 format)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End of time range (RFC3339 format)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Limit Maximum number of samples to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = CreateJobRequest

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = UpdateJobRequest

// RecordJobMetricsJSONRequestBody defines body for RecordJobMetrics for application/json ContentType.
type RecordJobMetricsJSONRequestBody = RecordMetricsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// List all jobs
	// (GET /jobs)
	ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams)
	// Create a new job
	// (POST /jobs)
	CreateJob(w http.ResponseWriter, r *http.Request)
	// Delete job
	// (DELETE /jobs/{jobId})
	DeleteJob(w http.ResponseWriter, r *http.Request, jobId JobId)
	// Get job details
	// (GET /jobs/{jobId})
	GetJob(w http.ResponseWriter, r *http.Request, jobId JobId)
	// Update job
	// (PATCH /jobs/{jobId})
	UpdateJob(w http.ResponseWriter, r *http.Request, jobId JobId)
	// Get job metrics history
	// (GET /jobs/{jobId}/metrics)
	GetJobMetrics(w http.ResponseWriter, r *http.Request, jobId JobId, params GetJobMetricsParams)
	// Record job metrics
	// (POST /jobs/{jobId}/metrics)
	RecordJobMetrics(w http.ResponseWriter, r *http.Request, jobId JobId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListJobs operation middleware
func (siw *ServerInterfaceWrapper) ListJobs(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "node" -------------

	err = runtime.BindQueryParameter("form", true, false, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateJob operation middleware
func (siw *ServerInterfaceWrapper) CreateJob(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJob(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteJob operation middleware
func (siw *ServerInterfaceWrapper) DeleteJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJob operation middleware
func (siw *ServerInterfaceWrapper) GetJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateJob operation middleware
func (siw *ServerInterfaceWrapper) UpdateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJobMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetJobMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobMetricsParams

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", r.URL.Query(), &params.StartTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_time", Err: err})
		return
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", r.URL.Query(), &params.EndTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_time", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJobMetrics(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecordJobMetrics operation middleware
func (siw *ServerInterfaceWrapper) RecordJobMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecordJobMetrics(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/health", wrapper.GetHealth)
	m.HandleFunc("GET "+options.BaseURL+"/jobs", wrapper.ListJobs)
	m.HandleFunc("POST "+options.BaseURL+"/jobs", wrapper.CreateJob)
	m.HandleFunc("DELETE "+options.BaseURL+"/jobs/{jobId}", wrapper.DeleteJob)
	m.HandleFunc("GET "+options.BaseURL+"/jobs/{jobId}", wrapper.GetJob)
	m.HandleFunc("PATCH "+options.BaseURL+"/jobs/{jobId}", wrapper.UpdateJob)
	m.HandleFunc("GET "+options.BaseURL+"/jobs/{jobId}/metrics", wrapper.GetJobMetrics)
	m.HandleFunc("POST "+options.BaseURL+"/jobs/{jobId}/metrics", wrapper.RecordJobMetrics)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbbW/bOBL+K4TugG0Bx5adZJH4Wy9Juw7SNJekX64bGLQ0ttlKpEpSSX0L//cDh6Je",
	"LCp2kqLXBQossIpFcYbDZ94esn8FkUgzwYFrFYz/CjIqaQoaJP51LmaT2DzEoCLJMs0ED8bBR86+5kA+",
	"ixlhMXDN5gxk0AvgG02zBIJx8FnM9sJwGPQCZj7IqF4GvYDTtHg5iYNeIOFrziTEwVjLHHqBipaQUiMu",
	"pd8ugC/0MhiPDg97Qcq4+3vYC/QqM9MoLRlfBOv12n2KOp9IoBrOxewavuagNK5KigykZoAj2BOW9CRN",
	"egEXsZXRnP2CKU3EnJjXxFhBES0ITRIRUQ3GShpS/K41Y8r4xL6s5FEp6Soolh3nCUjz6T8lzINx8I9B",
	"taODwi6DGzdwwufCfJkr+9GGFRRI8rAUROWzlGkNMdFLtMpTTbGub+8nY/JCprPRXfmJmH2GSBulzqQU",
	"8hpUJriC9r7FoClL8JHGMTM60+SqNsTCqLmkN+VIAmZ64mbxyMcBbaugWiQSMTQwzoWezkXO48ADhBSU",
	"ogtoT/ZHnlK+J4HGdJZAoZMbXZ/+XMzIA9NLMjklvxl/Oj4+/o1woUmH0A2T28VUmvgM/gfQRC+7La40",
	"1bkHzye5lMA1WeL3xA4zADdoUSDvWYSL4XlqVLHDVoHZm4WkMSAauPv5zmM/zVJQmqZZW/gtS8HIKoRH",
	"S4i+BL1gLmRKdTAOYqphz3zv25d7kAqn2Zz1xmpN3IBt5i1MU9fUZ+FzMWubNcryae6Hh7PsydVHgkNI",
	"BjICri08qkWKfJaA9UqWGjMPwxB90v4VlrrwPJ2BRHjzeIp2aUk1WAMeE/OWvGJzYkJIAsb/hSRzyhKI",
	"X+9s48X25b3zLI+8Epn11NcvXSl7YdLyuHMq5MquaprOuhdmBxZrY5yksKCzlQaDFI/KjGtYWJ13Tx0u",
	"b8QmiVTxuVzIJ5xrD1din0YGm905ZjOtyJybvZ0qiASPPUrdCk0TUgwzy3QjffvW2p3nZy2lqdSPYBjf",
	"kwKXu4HV+DFsU+RczG5w3PMyZwUxmtjI+NRs6fRsmKAj3hjEdIf0z2JmiyCHhi3r9uEjYSnTbRu8tw5K",
	"7E4b0BphRILOJYdaxqqhXsznCjxzXTbnUF9YlnVMoQ0YuzC6oUtKdbRkfIGbM2eJRhtvzrmxHWgyJ8et",
	"vlS9Yxfeg5YsUo9uxNQXp843A1Qbsoim3XfRqnJjMejZzh0NWIh9bD/bhpsilp3GTlaHzW6cL/pjK7qA",
	"qzIKzyoqjAx4bKyDsYvbpzKHmViAKcz8SHkEiXn2VR0NSz0pbfvyGdVEL5kimWBcmyjZCkzPSG2PJNd3",
	"OyvxHVPt1sz4visjdtrn8Ty5rTJ8WAK3dShuI3mgBrKRkLbs3CUrbMC4ktirYaC9dB+qr1FyGQw6OtIn",
	"IutHY+hnQMsWXGxs2VO3qVlpeLTSNKaakrkUKYILvmmQpql8EPJLImhMUsrpAiR5Bf1Fv0duLj5ev3/d",
	"/5PfGogzbs3GBCeI+CxPsIJDtGJqohKIWvEIYiuF8kpIWTH1/zSdSRM8NIpEzj059I19McikMOsk0ZLK",
	"hZleSG9xUoybDkf7vrQD35ieYhfs7x++MY1NMnlF7ylLsL2lcw3SdRNM8Nd1gV73dmuePpYfJ6cYLur7",
	"UJqosQHEztIQGwxH+weH/hVqSZ9NL5Qa7KkMIjZnEUkL3PjIhoxKzbS/Fy3XUg4afM0htw1AYy2LLPet",
	"JJNMSKZXfvO5t86Ile1QSl0AunR7l74KT1fw75wmZlYxJ66bTuAekg3WRKZYRrV0lvRhqvwVwAfJFgxt",
	"jCWA/aZyxkr/GcyFBGKFsP+iw/X/5G+FtHgYk6uzy9PJ5bseuf54eYkPJx/eX12c3Z6d9sjbN5ML8/+T",
	"N5cnZxf4eDt5f/bh422PXH44PZuaAT0COrKOWC2rmGRy+c5bsWFT0NG4NLOW6U9Nyqr1EaK5yJ1bG/tD",
	"S9wqwyKqMppeUl2EL2UzcrO4SgUSLCrJZWqiZ7Vq+5Mvf7bg/jGLt9CyjST4/fLb985Xj1cnT2wn25Yy",
	"P7EiCUWCaxqhqQrq/I+rE/JhpkDe0xlDZ7sFmhrBG2HJbOEeeh9JBWdaoMdQHhPR+Lwg6zAnmMmB3zMp",
	"eGr0dcnrzdWEZFLcs9gUbVEECulrg1QX4HrWM1UPRUhQIpcRFGk8tdWPdRnTABf9ULGmNxmNlkBG/dB0",
	"vTIJxsFS60yNB4OHh4c+xdd9IReD4ls1uJicnF3enO2N+mF/qdPE1oU6cSYyQa5pJheQ3lxNghoLGAz7",
	"YT/ERjQDTjMWjIP9ftg3CTCjeonAHFim0TwufL3qNTZECr10CyNq8I5BaRKbYgu0ZWDxMMQ2iihxFIZu",
	"/8FmdpplCYvw08FnZZNG6YcVUVujWmt1cjAKR7/vhcO9UXg7DMeh+e8/wbp+4vIYXDdYYoSonzxlijgF",
	"8FQmT1MqV2ZTmlytpgtVEcPBnRk8cMzEozamJCkIMZok5AsXD0X5hFS5q1OL1t72gU2bXzClz21DXz/r",
	"+rQp8C3OQGYrxLljX/A062sOclUdZ5XMzE7GrPt+t8yC/PGJK15V0qpwbF55i7fHRJXEYoc8bs89fPIq",
	"mnGrvA5uSIuCTugQ7riWSnoMc5on2gXvWiivx/Khr0PYwjFpgTQThsKMmnpD24MAn2IF+ePVLNzSqty9",
	"1Nutp3xqpMyjw/5hI/MdHFoevEZrt7LZQXj8e8k8d9DGdc61HkjCIxdIyqxXI18sS1rwncb0NVXD+lFE",
	"OeXw+HZ4NN53U9ZUH/lUD1t67xttW9T18PeRQYZ3FUbkQXsVdeKoWMdMzAKzbwXzidhz1GVYMmij9ROi",
	"QIOm9cRUR/zjZq97wcFOKNlNfPOg1SN8wu9pwkwmx2KN1ELluhcc/lhVXIcH8h6kPTHdSC9oK5MQHFVb",
	"5Bf88870Q0J5k8qCKRMGKeHwYI+Gio5opTSkreRR3i0obi+A0v8S8epp3ltD9n7QQvFB6X2HBs8F/kzr",
	"njDYPWe3bkGsmxSJ6WXXrTg0/G7biicH7c00hVmEqsVE5VhKzvMkWf3fAT4z24hKHP84Jcojfmy6JqeE",
	"JhJovCLwjSn9c7qaBVblMW1vc7Xc4C+86LO2fmcCqs8DU3FvZjO+V/Xzfu87xUms923Ubr5lV0MG9h6T",
	"J/Ee+AkSq64Pogc/Fh3VdY+fEQt2Q/wo6D1ex7vGEfvFqHHAY+ovSkoOzc7eapy+KwyeWH/9bcqulwdr",
	"d1vqF/g3wf8ONEat2n2yVtVBdbT03BVAKqzqKwneACuZ4ibUS97sRWh/ZqnSroh3xlSL79upAAl/RAGS",
	"o2o/bQHyy8tqXlb5yvZCY1AQjVtJpCVTWkgW0aSDqtw9BxUnu891zhYncYM3mMTcHtNLyhdAXl2/Pdnf",
	"3z8mlsp+3c1DuYxRd9LdDrxbd155/Dwtys7+5Tq0OSN3BeVltNEmb7SNOPoefM10oyYo7/BssDij/n6z",
	"nBh56of946Owk+CtCoQN2sVbqnTUJo/MPbRz3z2P9di8FtURlJwfWk/9FRi7y49NS1VR0kXDbv7jBs8Y",
	"i17OTVRcm7ER0Bf47JWWl8e+lxQmdVgf9UdNWB/1vcAeheHOSPVe2/nBFErz2l4bJYV25eWmX/XM38Bt",
	"LbDqnuv1WPwIZ/GdTV0IU7rEcA+JyFLsnHFs4/x0PBgkZtxSKD0+Co/Cwf3Qhm0rzcd72EsAOKPpy2tN",
	"SfVPt5SnaqmH7PYBcPW5W6Cn7ilOEIvzU+Ax3gpU1bfFWeH6bv2/AAAA//9Df7WrtDYAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
