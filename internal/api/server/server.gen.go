// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
)

// Defines values for GPUVendor.
const (
	Amd    GPUVendor = "amd"
	Mixed  GPUVendor = "mixed"
	None   GPUVendor = "none"
	Nvidia GPUVendor = "nvidia"
)

// Defines values for HealthResponseStatus.
const (
	Degraded  HealthResponseStatus = "degraded"
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for JobEventResponseStatus.
const (
	Created JobEventResponseStatus = "created"
	Skipped JobEventResponseStatus = "skipped"
	Updated JobEventResponseStatus = "updated"
)

// Defines values for JobState.
const (
	Cancelled JobState = "cancelled"
	Completed JobState = "completed"
	Failed    JobState = "failed"
	Pending   JobState = "pending"
	Running   JobState = "running"
)

// Defines values for SchedulerInfoType.
const (
	Mock  SchedulerInfoType = "mock"
	Slurm SchedulerInfoType = "slurm"
)

// CreateJobRequest defines model for CreateJobRequest.
type CreateJobRequest struct {
	// Id Unique job identifier
	Id string `json:"id"`

	// Nodes List of node names to allocate
	Nodes []string `json:"nodes"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// User User who submitted the job
	User string `json:"user"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// GPUVendor GPU vendor type
type GPUVendor string

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status Current health status of the service
	Status HealthResponseStatus `json:"status"`

	// Timestamp Time of health check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version *string `json:"version,omitempty"`
}

// HealthResponseStatus Current health status of the service
type HealthResponseStatus string

// Job defines model for Job.
type Job struct {
	// AllocatedCpus CPUs allocated to the job
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// AllocatedGpus GPUs allocated to the job
	AllocatedGpus *int `json:"allocated_gpus,omitempty"`

	// AllocatedMemoryMb Memory allocated to the job (MB)
	AllocatedMemoryMb *int `json:"allocated_memory_mb,omitempty"`

	// AvgCpuUsage Average CPU usage across samples
	AvgCpuUsage *float64 `json:"avg_cpu_usage,omitempty"`

	// AvgGpuUsage Average GPU usage across samples
	AvgGpuUsage *float64 `json:"avg_gpu_usage,omitempty"`

	// ClusterName Cluster identifier for multi-cluster deployments
	ClusterName *string `json:"cluster_name,omitempty"`

	// CpuUsage Current CPU usage percentage
	CpuUsage *float64 `json:"cpu_usage,omitempty"`

	// EndTime Job end time (if completed or failed)
	EndTime *time.Time `json:"end_time,omitempty"`

	// GpuUsage Current GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// Id Unique job identifier
	Id string `json:"id"`

	// IngestVersion Ingestion pipeline version
	IngestVersion *string `json:"ingest_version,omitempty"`

	// LastSampleAt Timestamp of the latest metrics sample
	LastSampleAt *time.Time `json:"last_sample_at,omitempty"`

	// MaxCpuUsage Maximum CPU usage across samples
	MaxCpuUsage *float64 `json:"max_cpu_usage,omitempty"`

	// MaxGpuUsage Maximum GPU usage across samples
	MaxGpuUsage *float64 `json:"max_gpu_usage,omitempty"`

	// MaxMemoryUsageMb Maximum memory usage across samples (MB)
	MaxMemoryUsageMb *int `json:"max_memory_usage_mb,omitempty"`

	// MemoryUsageMb Current memory usage in megabytes
	MemoryUsageMb *int `json:"memory_usage_mb,omitempty"`

	// NodeCount Number of nodes allocated to the job
	NodeCount *int `json:"node_count,omitempty"`

	// Nodes List of node names allocated to the job
	Nodes []string `json:"nodes"`

	// RequestedCpus CPUs requested by the job
	RequestedCpus *int `json:"requested_cpus,omitempty"`

	// RequestedGpus GPUs requested by the job
	RequestedGpus *int `json:"requested_gpus,omitempty"`

	// RequestedMemoryMb Memory requested by the job (MB)
	RequestedMemoryMb *int `json:"requested_memory_mb,omitempty"`

	// RuntimeSeconds Total runtime in seconds
	RuntimeSeconds *float64 `json:"runtime_seconds,omitempty"`

	// SampleCount Total number of metrics samples recorded for the job
	SampleCount *int `json:"sample_count,omitempty"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// SchedulerInstance Scheduler instance identifier
	SchedulerInstance *string `json:"scheduler_instance,omitempty"`

	// StartTime Job start time
	StartTime time.Time `json:"start_time"`

	// State Current state of the job
	State JobState `json:"state"`

	// User User who submitted the job
	User string `json:"user"`
}

// JobEventResponse defines model for JobEventResponse.
type JobEventResponse struct {
	// JobId Job identifier
	JobId string `json:"job_id"`

	// Message Optional message with details
	Message *string `json:"message,omitempty"`

	// Status Result of processing the event
	Status JobEventResponseStatus `json:"status"`
}

// JobEventResponseStatus Result of processing the event
type JobEventResponseStatus string

// JobFinishedEvent Event emitted by Slurm epilog script when a job finishes
type JobFinishedEvent struct {
	// ExitCode Job exit code
	ExitCode *int `json:"exit_code,omitempty"`

	// FinalState Current state of the job
	FinalState JobState `json:"final_state"`

	// JobId Slurm job ID
	JobId string `json:"job_id"`

	// Signal Signal that killed the job (if applicable)
	Signal *int `json:"signal,omitempty"`

	// Timestamp Event timestamp
	Timestamp time.Time `json:"timestamp"`
}

// JobListResponse defines model for JobListResponse.
type JobListResponse struct {
	Jobs []Job `json:"jobs"`

	// Limit Maximum number of jobs returned
	Limit int `json:"limit"`

	// Offset Number of jobs skipped
	Offset int `json:"offset"`

	// Total Total number of jobs matching the filter
	Total int `json:"total"`
}

// JobMetricsResponse defines model for JobMetricsResponse.
type JobMetricsResponse struct {
	// JobId Job identifier
	JobId   string         `json:"job_id"`
	Samples []MetricSample `json:"samples"`

	// Total Total number of samples returned
	Total int `json:"total"`
}

// JobStartedEvent Event emitted by Slurm prolog script when a job starts
type JobStartedEvent struct {
	// Account Slurm account name
	Account *string `json:"account,omitempty"`

	// CgroupPath Path to the job's cgroup
	CgroupPath *string `json:"cgroup_path,omitempty"`

	// CpuAllocation Number of CPUs allocated
	CpuAllocation *int `json:"cpu_allocation,omitempty"`

	// GpuAllocation Number of GPUs allocated
	GpuAllocation *int `json:"gpu_allocation,omitempty"`

	// GpuDevices GPU device identifiers (UUIDs or card IDs)
	GpuDevices *[]string `json:"gpu_devices,omitempty"`

	// GpuVendor GPU vendor type
	GpuVendor *GPUVendor `json:"gpu_vendor,omitempty"`

	// JobId Slurm job ID
	JobId string `json:"job_id"`

	// MemoryAllocationMb Memory allocated in MB
	MemoryAllocationMb *int `json:"memory_allocation_mb,omitempty"`

	// NodeList List of nodes allocated to the job
	NodeList []string `json:"node_list"`

	// Partition Slurm partition name
	Partition *string `json:"partition,omitempty"`

	// Timestamp Event timestamp
	Timestamp time.Time `json:"timestamp"`

	// User User who submitted the job
	User string `json:"user"`
}

// JobState Current state of the job
type JobState string

// MetricSample defines model for MetricSample.
type MetricSample struct {
	// CpuUsage CPU usage percentage at this point in time
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage at this point in time (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes at this point in time
	MemoryUsageMb int `json:"memory_usage_mb"`

	// Timestamp Time when the sample was recorded
	Timestamp time.Time `json:"timestamp"`
}

// RecordMetricsRequest defines model for RecordMetricsRequest.
type RecordMetricsRequest struct {
	// CpuUsage CPU usage percentage
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes
	MemoryUsageMb int `json:"memory_usage_mb"`
}

// SchedulerInfo Metadata from the external workload manager (e.g., SLURM).
// This information is populated when jobs are synced from an external scheduler.
type SchedulerInfo struct {
	// Account Account/project charged for the job
	Account *string `json:"account,omitempty"`

	// ExitCode Job exit code (available after completion)
	ExitCode *int `json:"exit_code,omitempty"`

	// ExternalJobId Job ID in the external scheduler (e.g., SLURM job_id)
	ExternalJobId *string `json:"external_job_id,omitempty"`

	// Extra Additional scheduler-specific metadata
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Partition Scheduler partition/queue name
	Partition *string `json:"partition,omitempty"`

	// Priority Job priority in the scheduler queue (Slurm uses uint32 which may exceed int32)
	Priority *int64 `json:"priority,omitempty"`

	// Qos Quality of Service level
	Qos *string `json:"qos,omitempty"`

	// RawState Original state string from the scheduler before normalization.
	// For SLURM: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT, NODE_FAIL, etc.
	RawState *string `json:"raw_state,omitempty"`

	// StateReason Scheduler-provided reason for state transitions
	StateReason *string `json:"state_reason,omitempty"`

	// SubmitTime Time when the job was submitted to the scheduler
	SubmitTime *time.Time `json:"submit_time,omitempty"`

	// TimeLimitMinutes Time limit in minutes
	TimeLimitMinutes *int `json:"time_limit_minutes,omitempty"`

	// Type Type of scheduler that manages this job
	Type *SchedulerInfoType `json:"type,omitempty"`
}

// SchedulerInfoType Type of scheduler that manages this job
type SchedulerInfoType string

// UpdateJobRequest defines model for UpdateJobRequest.
type UpdateJobRequest struct {
	CpuUsage      *float64 `json:"cpu_usage,omitempty"`
	GpuUsage      *float64 `json:"gpu_usage,omitempty"`
	MemoryUsageMb *int     `json:"memory_usage_mb,omitempty"`

	// State Current state of the job
	State *JobState `json:"state,omitempty"`
}

// ChangedByHeader defines model for ChangedByHeader.
type ChangedByHeader = string

// CorrelationIdHeader defines model for CorrelationIdHeader.
type CorrelationIdHeader = string

// JobId defines model for JobId.
type JobId = string

// SourceHeader defines model for SourceHeader.
type SourceHeader = string

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// State Filter by job state
	State *JobState `form:"state,omitempty" json:"state,omitempty"`

	// User Filter by user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Node Filter by node name
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Limit Maximum number of jobs to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of jobs to skip for pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateJobParams defines parameters for CreateJob.
type CreateJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// UpdateJobParams defines parameters for UpdateJob.
type UpdateJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// GetJobMetricsParams defines parameters for GetJobMetrics.
type GetJobMetricsParams struct {
	// StartTime Start of time range (RFC3339 format)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End of time range (RFC3339 format)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Limit Maximum number of samples to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// RecordJobMetricsParams defines parameters for RecordJobMetrics.
type RecordJobMetricsParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// JobFinishedEventJSONRequestBody defines body for JobFinishedEvent for application/json ContentType.
type JobFinishedEventJSONRequestBody = JobFinishedEvent

// JobStartedEventJSONRequestBody defines body for JobStartedEvent for application/json ContentType.
type JobStartedEventJSONRequestBody = JobStartedEvent

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = CreateJobRequest

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = UpdateJobRequest

// RecordJobMetricsJSONRequestBody defines body for RecordJobMetrics for application/json ContentType.
type RecordJobMetricsJSONRequestBody = RecordMetricsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Job finished event
	// (POST /events/job-finished)
	JobFinishedEvent(ctx echo.Context) error
	// Job started event
	// (POST /events/job-started)
	JobStartedEvent(ctx echo.Context) error
	// Health check
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// List all jobs
	// (GET /jobs)
	ListJobs(ctx echo.Context, params ListJobsParams) error
	// Create a new job
	// (POST /jobs)
	CreateJob(ctx echo.Context, params CreateJobParams) error
	// Delete job
	// (DELETE /jobs/{jobId})
	DeleteJob(ctx echo.Context, jobId JobId, params DeleteJobParams) error
	// Get job details
	// (GET /jobs/{jobId})
	GetJob(ctx echo.Context, jobId JobId) error
	// Update job
	// (PATCH /jobs/{jobId})
	UpdateJob(ctx echo.Context, jobId JobId, params UpdateJobParams) error
	// Get job metrics history
	// (GET /jobs/{jobId}/metrics)
	GetJobMetrics(ctx echo.Context, jobId JobId, params GetJobMetricsParams) error
	// Record job metrics
	// (POST /jobs/{jobId}/metrics)
	RecordJobMetrics(ctx echo.Context, jobId JobId, params RecordJobMetricsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// JobFinishedEvent converts echo context to params.
func (w *ServerInterfaceWrapper) JobFinishedEvent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.JobFinishedEvent(ctx)
	return err
}

// JobStartedEvent converts echo context to params.
func (w *ServerInterfaceWrapper) JobStartedEvent(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.JobStartedEvent(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// ListJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListJobs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams
	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", ctx.QueryParams(), &params.User)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user: %s", err))
	}

	// ------------- Optional query parameter "node" -------------

	err = runtime.BindQueryParameter("form", true, false, "node", ctx.QueryParams(), &params.Node)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter node: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListJobs(ctx, params)
	return err
}

// CreateJob converts echo context to params.
func (w *ServerInterfaceWrapper) CreateJob(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateJobParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Changed-By, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Changed-By: %s", err))
		}

		params.XChangedBy = XChangedBy
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Changed-By is required, but not found"))
	}
	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Source, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Source: %s", err))
		}

		params.XSource = XSource
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Source is required, but not found"))
	}
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateJob(ctx, params)
	return err
}

// DeleteJob converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", ctx.Param("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jobId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteJobParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Changed-By, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Changed-By: %s", err))
		}

		params.XChangedBy = XChangedBy
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Changed-By is required, but not found"))
	}
	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Source, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Source: %s", err))
		}

		params.XSource = XSource
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Source is required, but not found"))
	}
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteJob(ctx, jobId, params)
	return err
}

// GetJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", ctx.Param("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jobId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJob(ctx, jobId)
	return err
}

// UpdateJob converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", ctx.Param("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jobId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateJobParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Changed-By, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Changed-By: %s", err))
		}

		params.XChangedBy = XChangedBy
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Changed-By is required, but not found"))
	}
	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Source, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Source: %s", err))
		}

		params.XSource = XSource
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Source is required, but not found"))
	}
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateJob(ctx, jobId, params)
	return err
}

// GetJobMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", ctx.Param("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jobId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobMetricsParams
	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetJobMetrics(ctx, jobId, params)
	return err
}

// RecordJobMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) RecordJobMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", ctx.Param("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter jobId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RecordJobMetricsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Changed-By, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Changed-By: %s", err))
		}

		params.XChangedBy = XChangedBy
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Changed-By is required, but not found"))
	}
	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Source, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Source: %s", err))
		}

		params.XSource = XSource
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Source is required, but not found"))
	}
	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Correlation-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Correlation-Id: %s", err))
		}

		params.XCorrelationId = &XCorrelationId
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RecordJobMetrics(ctx, jobId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/events/job-finished", wrapper.JobFinishedEvent)
	router.POST(baseURL+"/events/job-started", wrapper.JobStartedEvent)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.GET(baseURL+"/jobs", wrapper.ListJobs)
	router.POST(baseURL+"/jobs", wrapper.CreateJob)
	router.DELETE(baseURL+"/jobs/:jobId", wrapper.DeleteJob)
	router.GET(baseURL+"/jobs/:jobId", wrapper.GetJob)
	router.PATCH(baseURL+"/jobs/:jobId", wrapper.UpdateJob)
	router.GET(baseURL+"/jobs/:jobId/metrics", wrapper.GetJobMetrics)
	router.POST(baseURL+"/jobs/:jobId/metrics", wrapper.RecordJobMetrics)

}

type JobFinishedEventRequestObject struct {
	Body *JobFinishedEventJSONRequestBody
}

type JobFinishedEventResponseObject interface {
	VisitJobFinishedEventResponse(w http.ResponseWriter) error
}

type JobFinishedEvent200JSONResponse JobEventResponse

func (response JobFinishedEvent200JSONResponse) VisitJobFinishedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type JobFinishedEvent400JSONResponse ErrorResponse

func (response JobFinishedEvent400JSONResponse) VisitJobFinishedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type JobFinishedEvent404JSONResponse ErrorResponse

func (response JobFinishedEvent404JSONResponse) VisitJobFinishedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type JobFinishedEvent500JSONResponse ErrorResponse

func (response JobFinishedEvent500JSONResponse) VisitJobFinishedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type JobStartedEventRequestObject struct {
	Body *JobStartedEventJSONRequestBody
}

type JobStartedEventResponseObject interface {
	VisitJobStartedEventResponse(w http.ResponseWriter) error
}

type JobStartedEvent200JSONResponse JobEventResponse

func (response JobStartedEvent200JSONResponse) VisitJobStartedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type JobStartedEvent400JSONResponse ErrorResponse

func (response JobStartedEvent400JSONResponse) VisitJobStartedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type JobStartedEvent500JSONResponse ErrorResponse

func (response JobStartedEvent500JSONResponse) VisitJobStartedEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetHealthRequestObject struct {
}

type GetHealthResponseObject interface {
	VisitGetHealthResponse(w http.ResponseWriter) error
}

type GetHealth200JSONResponse HealthResponse

func (response GetHealth200JSONResponse) VisitGetHealthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListJobsRequestObject struct {
	Params ListJobsParams
}

type ListJobsResponseObject interface {
	VisitListJobsResponse(w http.ResponseWriter) error
}

type ListJobs200JSONResponse JobListResponse

func (response ListJobs200JSONResponse) VisitListJobsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListJobs400JSONResponse ErrorResponse

func (response ListJobs400JSONResponse) VisitListJobsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListJobs500JSONResponse ErrorResponse

func (response ListJobs500JSONResponse) VisitListJobsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobRequestObject struct {
	Params CreateJobParams
	Body   *CreateJobJSONRequestBody
}

type CreateJobResponseObject interface {
	VisitCreateJobResponse(w http.ResponseWriter) error
}

type CreateJob201JSONResponse Job

func (response CreateJob201JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateJob400JSONResponse ErrorResponse

func (response CreateJob400JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateJob409JSONResponse ErrorResponse

func (response CreateJob409JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreateJob500JSONResponse ErrorResponse

func (response CreateJob500JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteJobRequestObject struct {
	JobId  JobId `json:"jobId"`
	Params DeleteJobParams
}

type DeleteJobResponseObject interface {
	VisitDeleteJobResponse(w http.ResponseWriter) error
}

type DeleteJob204Response struct {
}

func (response DeleteJob204Response) VisitDeleteJobResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteJob404JSONResponse ErrorResponse

func (response DeleteJob404JSONResponse) VisitDeleteJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteJob500JSONResponse ErrorResponse

func (response DeleteJob500JSONResponse) VisitDeleteJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetJobRequestObject struct {
	JobId JobId `json:"jobId"`
}

type GetJobResponseObject interface {
	VisitGetJobResponse(w http.ResponseWriter) error
}

type GetJob200JSONResponse Job

func (response GetJob200JSONResponse) VisitGetJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetJob404JSONResponse ErrorResponse

func (response GetJob404JSONResponse) VisitGetJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetJob500JSONResponse ErrorResponse

func (response GetJob500JSONResponse) VisitGetJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJobRequestObject struct {
	JobId  JobId `json:"jobId"`
	Params UpdateJobParams
	Body   *UpdateJobJSONRequestBody
}

type UpdateJobResponseObject interface {
	VisitUpdateJobResponse(w http.ResponseWriter) error
}

type UpdateJob200JSONResponse Job

func (response UpdateJob200JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob400JSONResponse ErrorResponse

func (response UpdateJob400JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob404JSONResponse ErrorResponse

func (response UpdateJob404JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob500JSONResponse ErrorResponse

func (response UpdateJob500JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetJobMetricsRequestObject struct {
	JobId  JobId `json:"jobId"`
	Params GetJobMetricsParams
}

type GetJobMetricsResponseObject interface {
	VisitGetJobMetricsResponse(w http.ResponseWriter) error
}

type GetJobMetrics200JSONResponse JobMetricsResponse

func (response GetJobMetrics200JSONResponse) VisitGetJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetJobMetrics404JSONResponse ErrorResponse

func (response GetJobMetrics404JSONResponse) VisitGetJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetJobMetrics500JSONResponse ErrorResponse

func (response GetJobMetrics500JSONResponse) VisitGetJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RecordJobMetricsRequestObject struct {
	JobId  JobId `json:"jobId"`
	Params RecordJobMetricsParams
	Body   *RecordJobMetricsJSONRequestBody
}

type RecordJobMetricsResponseObject interface {
	VisitRecordJobMetricsResponse(w http.ResponseWriter) error
}

type RecordJobMetrics201JSONResponse MetricSample

func (response RecordJobMetrics201JSONResponse) VisitRecordJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type RecordJobMetrics400JSONResponse ErrorResponse

func (response RecordJobMetrics400JSONResponse) VisitRecordJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RecordJobMetrics404JSONResponse ErrorResponse

func (response RecordJobMetrics404JSONResponse) VisitRecordJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RecordJobMetrics500JSONResponse ErrorResponse

func (response RecordJobMetrics500JSONResponse) VisitRecordJobMetricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Job finished event
	// (POST /events/job-finished)
	JobFinishedEvent(ctx context.Context, request JobFinishedEventRequestObject) (JobFinishedEventResponseObject, error)
	// Job started event
	// (POST /events/job-started)
	JobStartedEvent(ctx context.Context, request JobStartedEventRequestObject) (JobStartedEventResponseObject, error)
	// Health check
	// (GET /health)
	GetHealth(ctx context.Context, request GetHealthRequestObject) (GetHealthResponseObject, error)
	// List all jobs
	// (GET /jobs)
	ListJobs(ctx context.Context, request ListJobsRequestObject) (ListJobsResponseObject, error)
	// Create a new job
	// (POST /jobs)
	CreateJob(ctx context.Context, request CreateJobRequestObject) (CreateJobResponseObject, error)
	// Delete job
	// (DELETE /jobs/{jobId})
	DeleteJob(ctx context.Context, request DeleteJobRequestObject) (DeleteJobResponseObject, error)
	// Get job details
	// (GET /jobs/{jobId})
	GetJob(ctx context.Context, request GetJobRequestObject) (GetJobResponseObject, error)
	// Update job
	// (PATCH /jobs/{jobId})
	UpdateJob(ctx context.Context, request UpdateJobRequestObject) (UpdateJobResponseObject, error)
	// Get job metrics history
	// (GET /jobs/{jobId}/metrics)
	GetJobMetrics(ctx context.Context, request GetJobMetricsRequestObject) (GetJobMetricsResponseObject, error)
	// Record job metrics
	// (POST /jobs/{jobId}/metrics)
	RecordJobMetrics(ctx context.Context, request RecordJobMetricsRequestObject) (RecordJobMetricsResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// JobFinishedEvent operation middleware
func (sh *strictHandler) JobFinishedEvent(ctx echo.Context) error {
	var request JobFinishedEventRequestObject

	var body JobFinishedEventJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.JobFinishedEvent(ctx.Request().Context(), request.(JobFinishedEventRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "JobFinishedEvent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(JobFinishedEventResponseObject); ok {
		return validResponse.VisitJobFinishedEventResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// JobStartedEvent operation middleware
func (sh *strictHandler) JobStartedEvent(ctx echo.Context) error {
	var request JobStartedEventRequestObject

	var body JobStartedEventJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.JobStartedEvent(ctx.Request().Context(), request.(JobStartedEventRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "JobStartedEvent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(JobStartedEventResponseObject); ok {
		return validResponse.VisitJobStartedEventResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetHealth operation middleware
func (sh *strictHandler) GetHealth(ctx echo.Context) error {
	var request GetHealthRequestObject

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetHealth(ctx.Request().Context(), request.(GetHealthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetHealth")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetHealthResponseObject); ok {
		return validResponse.VisitGetHealthResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// ListJobs operation middleware
func (sh *strictHandler) ListJobs(ctx echo.Context, params ListJobsParams) error {
	var request ListJobsRequestObject

	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListJobs(ctx.Request().Context(), request.(ListJobsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListJobs")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(ListJobsResponseObject); ok {
		return validResponse.VisitListJobsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateJob operation middleware
func (sh *strictHandler) CreateJob(ctx echo.Context, params CreateJobParams) error {
	var request CreateJobRequestObject

	request.Params = params

	var body CreateJobJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateJob(ctx.Request().Context(), request.(CreateJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateJob")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(CreateJobResponseObject); ok {
		return validResponse.VisitCreateJobResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteJob operation middleware
func (sh *strictHandler) DeleteJob(ctx echo.Context, jobId JobId, params DeleteJobParams) error {
	var request DeleteJobRequestObject

	request.JobId = jobId
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteJob(ctx.Request().Context(), request.(DeleteJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteJob")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(DeleteJobResponseObject); ok {
		return validResponse.VisitDeleteJobResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetJob operation middleware
func (sh *strictHandler) GetJob(ctx echo.Context, jobId JobId) error {
	var request GetJobRequestObject

	request.JobId = jobId

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetJob(ctx.Request().Context(), request.(GetJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetJob")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetJobResponseObject); ok {
		return validResponse.VisitGetJobResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateJob operation middleware
func (sh *strictHandler) UpdateJob(ctx echo.Context, jobId JobId, params UpdateJobParams) error {
	var request UpdateJobRequestObject

	request.JobId = jobId
	request.Params = params

	var body UpdateJobJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateJob(ctx.Request().Context(), request.(UpdateJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateJob")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(UpdateJobResponseObject); ok {
		return validResponse.VisitUpdateJobResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetJobMetrics operation middleware
func (sh *strictHandler) GetJobMetrics(ctx echo.Context, jobId JobId, params GetJobMetricsParams) error {
	var request GetJobMetricsRequestObject

	request.JobId = jobId
	request.Params = params

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetJobMetrics(ctx.Request().Context(), request.(GetJobMetricsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetJobMetrics")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(GetJobMetricsResponseObject); ok {
		return validResponse.VisitGetJobMetricsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// RecordJobMetrics operation middleware
func (sh *strictHandler) RecordJobMetrics(ctx echo.Context, jobId JobId, params RecordJobMetricsParams) error {
	var request RecordJobMetricsRequestObject

	request.JobId = jobId
	request.Params = params

	var body RecordJobMetricsJSONRequestBody
	if err := ctx.Bind(&body); err != nil {
		return err
	}
	request.Body = &body

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RecordJobMetrics(ctx.Request().Context(), request.(RecordJobMetricsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RecordJobMetrics")
	}

	response, err := handler(ctx, request)

	if err != nil {
		return err
	} else if validResponse, ok := response.(RecordJobMetricsResponseObject); ok {
		return validResponse.VisitRecordJobMetricsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"7to+H+ZR5bvuivr+2/3/BwAA//8FHL5G7FQAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
