//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for HealthResponseStatus.
const (
	Degraded  HealthResponseStatus = "degraded"
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for JobState.
const (
	Cancelled JobState = "cancelled"
	Completed JobState = "completed"
	Failed    JobState = "failed"
	Pending   JobState = "pending"
	Running   JobState = "running"
)

// Defines values for SchedulerInfoType.
const (
	Mock  SchedulerInfoType = "mock"
	Slurm SchedulerInfoType = "slurm"
)

// CreateJobRequest defines model for CreateJobRequest.
type CreateJobRequest struct {
	// Id Unique job identifier
	Id string `json:"id"`

	// Nodes List of node names to allocate
	Nodes []string `json:"nodes"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// User User who submitted the job
	User string `json:"user"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status Current health status of the service
	Status HealthResponseStatus `json:"status"`

	// Timestamp Time of health check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version *string `json:"version,omitempty"`
}

// HealthResponseStatus Current health status of the service
type HealthResponseStatus string

// Job defines model for Job.
type Job struct {
	// AllocatedCpus CPUs allocated to the job
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// AllocatedGpus GPUs allocated to the job
	AllocatedGpus *int `json:"allocated_gpus,omitempty"`

	// AllocatedMemoryMb Memory allocated to the job (MB)
	AllocatedMemoryMb *int `json:"allocated_memory_mb,omitempty"`

	// AvgCpuUsage Average CPU usage across samples
	AvgCpuUsage *float64 `json:"avg_cpu_usage,omitempty"`

	// AvgGpuUsage Average GPU usage across samples
	AvgGpuUsage *float64 `json:"avg_gpu_usage,omitempty"`

	// ClusterName Cluster identifier for multi-cluster deployments
	ClusterName *string `json:"cluster_name,omitempty"`

	// CpuUsage Current CPU usage percentage
	CpuUsage *float64 `json:"cpu_usage,omitempty"`

	// EndTime Job end time (if completed or failed)
	EndTime *time.Time `json:"end_time,omitempty"`

	// GpuUsage Current GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// Id Unique job identifier
	Id string `json:"id"`

	// IngestVersion Ingestion pipeline version
	IngestVersion *string `json:"ingest_version,omitempty"`

	// LastSampleAt Timestamp of the latest metrics sample
	LastSampleAt *time.Time `json:"last_sample_at,omitempty"`

	// MaxCpuUsage Maximum CPU usage across samples
	MaxCpuUsage *float64 `json:"max_cpu_usage,omitempty"`

	// MaxGpuUsage Maximum GPU usage across samples
	MaxGpuUsage *float64 `json:"max_gpu_usage,omitempty"`

	// MaxMemoryUsageMb Maximum memory usage across samples (MB)
	MaxMemoryUsageMb *int `json:"max_memory_usage_mb,omitempty"`

	// MemoryUsageMb Current memory usage in megabytes
	MemoryUsageMb *int `json:"memory_usage_mb,omitempty"`

	// NodeCount Number of nodes allocated to the job
	NodeCount *int `json:"node_count,omitempty"`

	// Nodes List of node names allocated to the job
	Nodes []string `json:"nodes"`

	// RequestedCpus CPUs requested by the job
	RequestedCpus *int `json:"requested_cpus,omitempty"`

	// RequestedGpus GPUs requested by the job
	RequestedGpus *int `json:"requested_gpus,omitempty"`

	// RequestedMemoryMb Memory requested by the job (MB)
	RequestedMemoryMb *int `json:"requested_memory_mb,omitempty"`

	// RuntimeSeconds Total runtime in seconds
	RuntimeSeconds *float64 `json:"runtime_seconds,omitempty"`

	// SampleCount Total number of metrics samples recorded for the job
	SampleCount *int `json:"sample_count,omitempty"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// SchedulerInstance Scheduler instance identifier
	SchedulerInstance *string `json:"scheduler_instance,omitempty"`

	// StartTime Job start time
	StartTime time.Time `json:"start_time"`

	// State Current state of the job
	State JobState `json:"state"`

	// User User who submitted the job
	User string `json:"user"`
}

// JobListResponse defines model for JobListResponse.
type JobListResponse struct {
	Jobs []Job `json:"jobs"`

	// Limit Maximum number of jobs returned
	Limit int `json:"limit"`

	// Offset Number of jobs skipped
	Offset int `json:"offset"`

	// Total Total number of jobs matching the filter
	Total int `json:"total"`
}

// JobMetricsResponse defines model for JobMetricsResponse.
type JobMetricsResponse struct {
	// JobId Job identifier
	JobId   string         `json:"job_id"`
	Samples []MetricSample `json:"samples"`

	// Total Total number of samples returned
	Total int `json:"total"`
}

// JobState Current state of the job
type JobState string

// MetricSample defines model for MetricSample.
type MetricSample struct {
	// CpuUsage CPU usage percentage at this point in time
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage at this point in time (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes at this point in time
	MemoryUsageMb int `json:"memory_usage_mb"`

	// Timestamp Time when the sample was recorded
	Timestamp time.Time `json:"timestamp"`
}

// RecordMetricsRequest defines model for RecordMetricsRequest.
type RecordMetricsRequest struct {
	// CpuUsage CPU usage percentage
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes
	MemoryUsageMb int `json:"memory_usage_mb"`
}

// SchedulerInfo Metadata from the external workload manager (e.g., SLURM).
// This information is populated when jobs are synced from an external scheduler.
type SchedulerInfo struct {
	// Account Account/project charged for the job
	Account *string `json:"account,omitempty"`

	// ExitCode Job exit code (available after completion)
	ExitCode *int `json:"exit_code,omitempty"`

	// ExternalJobId Job ID in the external scheduler (e.g., SLURM job_id)
	ExternalJobId *string `json:"external_job_id,omitempty"`

	// Extra Additional scheduler-specific metadata
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Partition Scheduler partition/queue name
	Partition *string `json:"partition,omitempty"`

	// Priority Job priority in the scheduler queue (Slurm uses uint32 which may exceed int32)
	Priority *int64 `json:"priority,omitempty"`

	// Qos Quality of Service level
	Qos *string `json:"qos,omitempty"`

	// RawState Original state string from the scheduler before normalization.
	// For SLURM: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT, NODE_FAIL, etc.
	RawState *string `json:"raw_state,omitempty"`

	// StateReason Scheduler-provided reason for state transitions
	StateReason *string `json:"state_reason,omitempty"`

	// SubmitTime Time when the job was submitted to the scheduler
	SubmitTime *time.Time `json:"submit_time,omitempty"`

	// TimeLimitMinutes Time limit in minutes
	TimeLimitMinutes *int `json:"time_limit_minutes,omitempty"`

	// Type Type of scheduler that manages this job
	Type *SchedulerInfoType `json:"type,omitempty"`
}

// SchedulerInfoType Type of scheduler that manages this job
type SchedulerInfoType string

// UpdateJobRequest defines model for UpdateJobRequest.
type UpdateJobRequest struct {
	CpuUsage      *float64 `json:"cpu_usage,omitempty"`
	GpuUsage      *float64 `json:"gpu_usage,omitempty"`
	MemoryUsageMb *int     `json:"memory_usage_mb,omitempty"`

	// State Current state of the job
	State *JobState `json:"state,omitempty"`
}

// ChangedByHeader defines model for ChangedByHeader.
type ChangedByHeader = string

// CorrelationIdHeader defines model for CorrelationIdHeader.
type CorrelationIdHeader = string

// JobId defines model for JobId.
type JobId = string

// SourceHeader defines model for SourceHeader.
type SourceHeader = string

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// State Filter by job state
	State *JobState `form:"state,omitempty" json:"state,omitempty"`

	// User Filter by user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Node Filter by node name
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Limit Maximum number of jobs to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of jobs to skip for pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateJobParams defines parameters for CreateJob.
type CreateJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// UpdateJobParams defines parameters for UpdateJob.
type UpdateJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// GetJobMetricsParams defines parameters for GetJobMetrics.
type GetJobMetricsParams struct {
	// StartTime Start of time range (RFC3339 format)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End of time range (RFC3339 format)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Limit Maximum number of samples to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = CreateJobRequest

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = UpdateJobRequest

// RecordJobMetricsJSONRequestBody defines body for RecordJobMetrics for application/json ContentType.
type RecordJobMetricsJSONRequestBody = RecordMetricsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// List all jobs
	// (GET /jobs)
	ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams)
	// Create a new job
	// (POST /jobs)
	CreateJob(w http.ResponseWriter, r *http.Request, params CreateJobParams)
	// Delete job
	// (DELETE /jobs/{jobId})
	DeleteJob(w http.ResponseWriter, r *http.Request, jobId JobId, params DeleteJobParams)
	// Get job details
	// (GET /jobs/{jobId})
	GetJob(w http.ResponseWriter, r *http.Request, jobId JobId)
	// Update job
	// (PATCH /jobs/{jobId})
	UpdateJob(w http.ResponseWriter, r *http.Request, jobId JobId, params UpdateJobParams)
	// Get job metrics history
	// (GET /jobs/{jobId}/metrics)
	GetJobMetrics(w http.ResponseWriter, r *http.Request, jobId JobId, params GetJobMetricsParams)
	// Record job metrics
	// (POST /jobs/{jobId}/metrics)
	RecordJobMetrics(w http.ResponseWriter, r *http.Request, jobId JobId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListJobs operation middleware
func (siw *ServerInterfaceWrapper) ListJobs(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "node" -------------

	err = runtime.BindQueryParameter("form", true, false, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateJob operation middleware
func (siw *ServerInterfaceWrapper) CreateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Changed-By", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Changed-By", Err: err})
			return
		}

		params.XChangedBy = XChangedBy

	} else {
		err := fmt.Errorf("Header parameter X-Changed-By is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Changed-By", Err: err})
		return
	}

	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Source", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Source", Err: err})
			return
		}

		params.XSource = XSource

	} else {
		err := fmt.Errorf("Header parameter X-Source is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Source", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = &XCorrelationId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJob(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteJob operation middleware
func (siw *ServerInterfaceWrapper) DeleteJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Changed-By", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Changed-By", Err: err})
			return
		}

		params.XChangedBy = XChangedBy

	} else {
		err := fmt.Errorf("Header parameter X-Changed-By is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Changed-By", Err: err})
		return
	}

	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Source", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Source", Err: err})
			return
		}

		params.XSource = XSource

	} else {
		err := fmt.Errorf("Header parameter X-Source is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Source", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = &XCorrelationId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteJob(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJob operation middleware
func (siw *ServerInterfaceWrapper) GetJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateJob operation middleware
func (siw *ServerInterfaceWrapper) UpdateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Changed-By", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Changed-By", Err: err})
			return
		}

		params.XChangedBy = XChangedBy

	} else {
		err := fmt.Errorf("Header parameter X-Changed-By is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Changed-By", Err: err})
		return
	}

	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Source", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Source", Err: err})
			return
		}

		params.XSource = XSource

	} else {
		err := fmt.Errorf("Header parameter X-Source is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Source", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = &XCorrelationId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateJob(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJobMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetJobMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobMetricsParams

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", r.URL.Query(), &params.StartTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_time", Err: err})
		return
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", r.URL.Query(), &params.EndTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_time", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJobMetrics(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecordJobMetrics operation middleware
func (siw *ServerInterfaceWrapper) RecordJobMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecordJobMetrics(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/health", wrapper.GetHealth)
	m.HandleFunc("GET "+options.BaseURL+"/jobs", wrapper.ListJobs)
	m.HandleFunc("POST "+options.BaseURL+"/jobs", wrapper.CreateJob)
	m.HandleFunc("DELETE "+options.BaseURL+"/jobs/{jobId}", wrapper.DeleteJob)
	m.HandleFunc("GET "+options.BaseURL+"/jobs/{jobId}", wrapper.GetJob)
	m.HandleFunc("PATCH "+options.BaseURL+"/jobs/{jobId}", wrapper.UpdateJob)
	m.HandleFunc("GET "+options.BaseURL+"/jobs/{jobId}/metrics", wrapper.GetJobMetrics)
	m.HandleFunc("POST "+options.BaseURL+"/jobs/{jobId}/metrics", wrapper.RecordJobMetrics)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"xLuvqnw3OwhefVn9JwAA//++5J6lHkIAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
