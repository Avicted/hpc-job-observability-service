//go:build go1.22

// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for GPUVendor.
const (
	Amd    GPUVendor = "amd"
	Mixed  GPUVendor = "mixed"
	None   GPUVendor = "none"
	Nvidia GPUVendor = "nvidia"
)

// Defines values for HealthResponseStatus.
const (
	Degraded  HealthResponseStatus = "degraded"
	Healthy   HealthResponseStatus = "healthy"
	Unhealthy HealthResponseStatus = "unhealthy"
)

// Defines values for JobEventResponseStatus.
const (
	Created JobEventResponseStatus = "created"
	Skipped JobEventResponseStatus = "skipped"
	Updated JobEventResponseStatus = "updated"
)

// Defines values for JobState.
const (
	Cancelled JobState = "cancelled"
	Completed JobState = "completed"
	Failed    JobState = "failed"
	Pending   JobState = "pending"
	Running   JobState = "running"
)

// Defines values for SchedulerInfoType.
const (
	Mock  SchedulerInfoType = "mock"
	Slurm SchedulerInfoType = "slurm"
)

// CreateJobRequest defines model for CreateJobRequest.
type CreateJobRequest struct {
	// Id Unique job identifier
	Id string `json:"id"`

	// Nodes List of node names to allocate
	Nodes []string `json:"nodes"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// User User who submitted the job
	User string `json:"user"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error code
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// GPUVendor GPU vendor type
type GPUVendor string

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status Current health status of the service
	Status HealthResponseStatus `json:"status"`

	// Timestamp Time of health check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version *string `json:"version,omitempty"`
}

// HealthResponseStatus Current health status of the service
type HealthResponseStatus string

// Job defines model for Job.
type Job struct {
	// AllocatedCpus CPUs allocated to the job
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// AllocatedGpus GPUs allocated to the job
	AllocatedGpus *int `json:"allocated_gpus,omitempty"`

	// AllocatedMemoryMb Memory allocated to the job (MB)
	AllocatedMemoryMb *int `json:"allocated_memory_mb,omitempty"`

	// AvgCpuUsage Average CPU usage across samples
	AvgCpuUsage *float64 `json:"avg_cpu_usage,omitempty"`

	// AvgGpuUsage Average GPU usage across samples
	AvgGpuUsage *float64 `json:"avg_gpu_usage,omitempty"`

	// ClusterName Cluster identifier for multi-cluster deployments
	ClusterName *string `json:"cluster_name,omitempty"`

	// CpuUsage Current CPU usage percentage
	CpuUsage *float64 `json:"cpu_usage,omitempty"`

	// EndTime Job end time (if completed or failed)
	EndTime *time.Time `json:"end_time,omitempty"`

	// GpuUsage Current GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// Id Unique job identifier
	Id string `json:"id"`

	// IngestVersion Ingestion pipeline version
	IngestVersion *string `json:"ingest_version,omitempty"`

	// LastSampleAt Timestamp of the latest metrics sample
	LastSampleAt *time.Time `json:"last_sample_at,omitempty"`

	// MaxCpuUsage Maximum CPU usage across samples
	MaxCpuUsage *float64 `json:"max_cpu_usage,omitempty"`

	// MaxGpuUsage Maximum GPU usage across samples
	MaxGpuUsage *float64 `json:"max_gpu_usage,omitempty"`

	// MaxMemoryUsageMb Maximum memory usage across samples (MB)
	MaxMemoryUsageMb *int `json:"max_memory_usage_mb,omitempty"`

	// MemoryUsageMb Current memory usage in megabytes
	MemoryUsageMb *int `json:"memory_usage_mb,omitempty"`

	// NodeCount Number of nodes allocated to the job
	NodeCount *int `json:"node_count,omitempty"`

	// Nodes List of node names allocated to the job
	Nodes []string `json:"nodes"`

	// RequestedCpus CPUs requested by the job
	RequestedCpus *int `json:"requested_cpus,omitempty"`

	// RequestedGpus GPUs requested by the job
	RequestedGpus *int `json:"requested_gpus,omitempty"`

	// RequestedMemoryMb Memory requested by the job (MB)
	RequestedMemoryMb *int `json:"requested_memory_mb,omitempty"`

	// RuntimeSeconds Total runtime in seconds
	RuntimeSeconds *float64 `json:"runtime_seconds,omitempty"`

	// SampleCount Total number of metrics samples recorded for the job
	SampleCount *int `json:"sample_count,omitempty"`

	// Scheduler Metadata from the external workload manager (e.g., SLURM).
	// This information is populated when jobs are synced from an external scheduler.
	Scheduler *SchedulerInfo `json:"scheduler,omitempty"`

	// SchedulerInstance Scheduler instance identifier
	SchedulerInstance *string `json:"scheduler_instance,omitempty"`

	// StartTime Job start time
	StartTime time.Time `json:"start_time"`

	// State Current state of the job
	State JobState `json:"state"`

	// User User who submitted the job
	User string `json:"user"`
}

// JobEventResponse defines model for JobEventResponse.
type JobEventResponse struct {
	// JobId Job identifier
	JobId string `json:"job_id"`

	// Message Optional message with details
	Message *string `json:"message,omitempty"`

	// Status Result of processing the event
	Status JobEventResponseStatus `json:"status"`
}

// JobEventResponseStatus Result of processing the event
type JobEventResponseStatus string

// JobFinishedEvent Event emitted by Slurm epilog script when a job finishes
type JobFinishedEvent struct {
	// ExitCode Job exit code
	ExitCode *int `json:"exit_code,omitempty"`

	// FinalState Current state of the job
	FinalState JobState `json:"final_state"`

	// JobId Slurm job ID
	JobId string `json:"job_id"`

	// Signal Signal that killed the job (if applicable)
	Signal *int `json:"signal,omitempty"`

	// Timestamp Event timestamp
	Timestamp time.Time `json:"timestamp"`
}

// JobListResponse defines model for JobListResponse.
type JobListResponse struct {
	Jobs []Job `json:"jobs"`

	// Limit Maximum number of jobs returned
	Limit int `json:"limit"`

	// Offset Number of jobs skipped
	Offset int `json:"offset"`

	// Total Total number of jobs matching the filter
	Total int `json:"total"`
}

// JobMetricsResponse defines model for JobMetricsResponse.
type JobMetricsResponse struct {
	// JobId Job identifier
	JobId   string         `json:"job_id"`
	Samples []MetricSample `json:"samples"`

	// Total Total number of samples returned
	Total int `json:"total"`
}

// JobStartedEvent Event emitted by Slurm prolog script when a job starts
type JobStartedEvent struct {
	// Account Slurm account name
	Account *string `json:"account,omitempty"`

	// CgroupPath Path to the job's cgroup
	CgroupPath *string `json:"cgroup_path,omitempty"`

	// CpuAllocation Number of CPUs allocated
	CpuAllocation *int `json:"cpu_allocation,omitempty"`

	// GpuAllocation Number of GPUs allocated
	GpuAllocation *int `json:"gpu_allocation,omitempty"`

	// GpuDevices GPU device identifiers (UUIDs or card IDs)
	GpuDevices *[]string `json:"gpu_devices,omitempty"`

	// GpuVendor GPU vendor type
	GpuVendor *GPUVendor `json:"gpu_vendor,omitempty"`

	// JobId Slurm job ID
	JobId string `json:"job_id"`

	// MemoryAllocationMb Memory allocated in MB
	MemoryAllocationMb *int `json:"memory_allocation_mb,omitempty"`

	// NodeList List of nodes allocated to the job
	NodeList []string `json:"node_list"`

	// Partition Slurm partition name
	Partition *string `json:"partition,omitempty"`

	// Timestamp Event timestamp
	Timestamp time.Time `json:"timestamp"`

	// User User who submitted the job
	User string `json:"user"`
}

// JobState Current state of the job
type JobState string

// MetricSample defines model for MetricSample.
type MetricSample struct {
	// CpuUsage CPU usage percentage at this point in time
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage at this point in time (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes at this point in time
	MemoryUsageMb int `json:"memory_usage_mb"`

	// Timestamp Time when the sample was recorded
	Timestamp time.Time `json:"timestamp"`
}

// RecordMetricsRequest defines model for RecordMetricsRequest.
type RecordMetricsRequest struct {
	// CpuUsage CPU usage percentage
	CpuUsage float64 `json:"cpu_usage"`

	// GpuUsage GPU usage percentage (optional)
	GpuUsage *float64 `json:"gpu_usage,omitempty"`

	// MemoryUsageMb Memory usage in megabytes
	MemoryUsageMb int `json:"memory_usage_mb"`
}

// SchedulerInfo Metadata from the external workload manager (e.g., SLURM).
// This information is populated when jobs are synced from an external scheduler.
type SchedulerInfo struct {
	// Account Account/project charged for the job
	Account *string `json:"account,omitempty"`

	// ExitCode Job exit code (available after completion)
	ExitCode *int `json:"exit_code,omitempty"`

	// ExternalJobId Job ID in the external scheduler (e.g., SLURM job_id)
	ExternalJobId *string `json:"external_job_id,omitempty"`

	// Extra Additional scheduler-specific metadata
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// Partition Scheduler partition/queue name
	Partition *string `json:"partition,omitempty"`

	// Priority Job priority in the scheduler queue (Slurm uses uint32 which may exceed int32)
	Priority *int64 `json:"priority,omitempty"`

	// Qos Quality of Service level
	Qos *string `json:"qos,omitempty"`

	// RawState Original state string from the scheduler before normalization.
	// For SLURM: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, TIMEOUT, NODE_FAIL, etc.
	RawState *string `json:"raw_state,omitempty"`

	// StateReason Scheduler-provided reason for state transitions
	StateReason *string `json:"state_reason,omitempty"`

	// SubmitTime Time when the job was submitted to the scheduler
	SubmitTime *time.Time `json:"submit_time,omitempty"`

	// TimeLimitMinutes Time limit in minutes
	TimeLimitMinutes *int `json:"time_limit_minutes,omitempty"`

	// Type Type of scheduler that manages this job
	Type *SchedulerInfoType `json:"type,omitempty"`
}

// SchedulerInfoType Type of scheduler that manages this job
type SchedulerInfoType string

// UpdateJobRequest defines model for UpdateJobRequest.
type UpdateJobRequest struct {
	CpuUsage      *float64 `json:"cpu_usage,omitempty"`
	GpuUsage      *float64 `json:"gpu_usage,omitempty"`
	MemoryUsageMb *int     `json:"memory_usage_mb,omitempty"`

	// State Current state of the job
	State *JobState `json:"state,omitempty"`
}

// ChangedByHeader defines model for ChangedByHeader.
type ChangedByHeader = string

// CorrelationIdHeader defines model for CorrelationIdHeader.
type CorrelationIdHeader = string

// JobId defines model for JobId.
type JobId = string

// SourceHeader defines model for SourceHeader.
type SourceHeader = string

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// State Filter by job state
	State *JobState `form:"state,omitempty" json:"state,omitempty"`

	// User Filter by user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Node Filter by node name
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Limit Maximum number of jobs to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of jobs to skip for pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateJobParams defines parameters for CreateJob.
type CreateJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// UpdateJobParams defines parameters for UpdateJob.
type UpdateJobParams struct {
	// XChangedBy Identifier of the actor/system performing the change
	XChangedBy ChangedByHeader `json:"X-Changed-By"`

	// XSource Source system initiating the change (api, syncer, scheduler)
	XSource SourceHeader `json:"X-Source"`

	// XCorrelationId Correlation ID for tracing multi-step updates
	XCorrelationId *CorrelationIdHeader `json:"X-Correlation-Id,omitempty"`
}

// GetJobMetricsParams defines parameters for GetJobMetrics.
type GetJobMetricsParams struct {
	// StartTime Start of time range (RFC3339 format)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End of time range (RFC3339 format)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Limit Maximum number of samples to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// JobFinishedEventJSONRequestBody defines body for JobFinishedEvent for application/json ContentType.
type JobFinishedEventJSONRequestBody = JobFinishedEvent

// JobStartedEventJSONRequestBody defines body for JobStartedEvent for application/json ContentType.
type JobStartedEventJSONRequestBody = JobStartedEvent

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody = CreateJobRequest

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = UpdateJobRequest

// RecordJobMetricsJSONRequestBody defines body for RecordJobMetrics for application/json ContentType.
type RecordJobMetricsJSONRequestBody = RecordMetricsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Job finished event
	// (POST /events/job-finished)
	JobFinishedEvent(w http.ResponseWriter, r *http.Request)
	// Job started event
	// (POST /events/job-started)
	JobStartedEvent(w http.ResponseWriter, r *http.Request)
	// Health check
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// List all jobs
	// (GET /jobs)
	ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams)
	// Create a new job
	// (POST /jobs)
	CreateJob(w http.ResponseWriter, r *http.Request, params CreateJobParams)
	// Delete job
	// (DELETE /jobs/{jobId})
	DeleteJob(w http.ResponseWriter, r *http.Request, jobId JobId, params DeleteJobParams)
	// Get job details
	// (GET /jobs/{jobId})
	GetJob(w http.ResponseWriter, r *http.Request, jobId JobId)
	// Update job
	// (PATCH /jobs/{jobId})
	UpdateJob(w http.ResponseWriter, r *http.Request, jobId JobId, params UpdateJobParams)
	// Get job metrics history
	// (GET /jobs/{jobId}/metrics)
	GetJobMetrics(w http.ResponseWriter, r *http.Request, jobId JobId, params GetJobMetricsParams)
	// Record job metrics
	// (POST /jobs/{jobId}/metrics)
	RecordJobMetrics(w http.ResponseWriter, r *http.Request, jobId JobId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// JobFinishedEvent operation middleware
func (siw *ServerInterfaceWrapper) JobFinishedEvent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobFinishedEvent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// JobStartedEvent operation middleware
func (siw *ServerInterfaceWrapper) JobStartedEvent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobStartedEvent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListJobs operation middleware
func (siw *ServerInterfaceWrapper) ListJobs(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", true, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "node" -------------

	err = runtime.BindQueryParameter("form", true, false, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateJob operation middleware
func (siw *ServerInterfaceWrapper) CreateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Changed-By", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Changed-By", Err: err})
			return
		}

		params.XChangedBy = XChangedBy

	} else {
		err := fmt.Errorf("Header parameter X-Changed-By is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Changed-By", Err: err})
		return
	}

	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Source", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Source", Err: err})
			return
		}

		params.XSource = XSource

	} else {
		err := fmt.Errorf("Header parameter X-Source is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Source", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = &XCorrelationId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJob(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteJob operation middleware
func (siw *ServerInterfaceWrapper) DeleteJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Changed-By", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Changed-By", Err: err})
			return
		}

		params.XChangedBy = XChangedBy

	} else {
		err := fmt.Errorf("Header parameter X-Changed-By is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Changed-By", Err: err})
		return
	}

	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Source", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Source", Err: err})
			return
		}

		params.XSource = XSource

	} else {
		err := fmt.Errorf("Header parameter X-Source is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Source", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = &XCorrelationId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteJob(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJob operation middleware
func (siw *ServerInterfaceWrapper) GetJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateJob operation middleware
func (siw *ServerInterfaceWrapper) UpdateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Changed-By" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Changed-By")]; found {
		var XChangedBy ChangedByHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Changed-By", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Changed-By", valueList[0], &XChangedBy, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Changed-By", Err: err})
			return
		}

		params.XChangedBy = XChangedBy

	} else {
		err := fmt.Errorf("Header parameter X-Changed-By is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Changed-By", Err: err})
		return
	}

	// ------------- Required header parameter "X-Source" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Source")]; found {
		var XSource SourceHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Source", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Source", valueList[0], &XSource, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Source", Err: err})
			return
		}

		params.XSource = XSource

	} else {
		err := fmt.Errorf("Header parameter X-Source is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Source", Err: err})
		return
	}

	// ------------- Optional header parameter "X-Correlation-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-Id")]; found {
		var XCorrelationId CorrelationIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Correlation-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-Id", valueList[0], &XCorrelationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Correlation-Id", Err: err})
			return
		}

		params.XCorrelationId = &XCorrelationId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateJob(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJobMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetJobMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobMetricsParams

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", r.URL.Query(), &params.StartTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_time", Err: err})
		return
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", r.URL.Query(), &params.EndTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_time", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJobMetrics(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecordJobMetrics operation middleware
func (siw *ServerInterfaceWrapper) RecordJobMetrics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "jobId" -------------
	var jobId JobId

	err = runtime.BindStyledParameterWithOptions("simple", "jobId", r.PathValue("jobId"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jobId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecordJobMetrics(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/events/job-finished", wrapper.JobFinishedEvent)
	m.HandleFunc("POST "+options.BaseURL+"/events/job-started", wrapper.JobStartedEvent)
	m.HandleFunc("GET "+options.BaseURL+"/health", wrapper.GetHealth)
	m.HandleFunc("GET "+options.BaseURL+"/jobs", wrapper.ListJobs)
	m.HandleFunc("POST "+options.BaseURL+"/jobs", wrapper.CreateJob)
	m.HandleFunc("DELETE "+options.BaseURL+"/jobs/{jobId}", wrapper.DeleteJob)
	m.HandleFunc("GET "+options.BaseURL+"/jobs/{jobId}", wrapper.GetJob)
	m.HandleFunc("PATCH "+options.BaseURL+"/jobs/{jobId}", wrapper.UpdateJob)
	m.HandleFunc("GET "+options.BaseURL+"/jobs/{jobId}/metrics", wrapper.GetJobMetrics)
	m.HandleFunc("POST "+options.BaseURL+"/jobs/{jobId}/metrics", wrapper.RecordJobMetrics)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"PB+ZUeW77iL44evD/wYAAP//tKOAgFJUAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
