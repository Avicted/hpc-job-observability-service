// Package slurmclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package slurmclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"gopkg.in/yaml.v2"

	"github.com/oapi-codegen/runtime"
)

const (
	TokenScopes = "token.Scopes"
	UserScopes  = "user.Scopes"
)

// Defines values for JobPropertiesExclusive0.
const (
	JobPropertiesExclusive0Mcs  JobPropertiesExclusive0 = "mcs"
	JobPropertiesExclusive0User JobPropertiesExclusive0 = "user"
)

// Defines values for JobPropertiesGresFlags.
const (
	JobPropertiesGresFlagsDisableBinding JobPropertiesGresFlags = "disable-binding"
	JobPropertiesGresFlagsEnforceBinding JobPropertiesGresFlags = "enforce-binding"
)

// Defines values for JobPropertiesOpenMode.
const (
	JobPropertiesOpenModeAppend   JobPropertiesOpenMode = "append"
	JobPropertiesOpenModeTruncate JobPropertiesOpenMode = "truncate"
)

// Defines values for Signal1.
const (
	Signal1ABRT Signal1 = "ABRT"
	Signal1ALRM Signal1 = "ALRM"
	Signal1CONT Signal1 = "CONT"
	Signal1HUP  Signal1 = "HUP"
	Signal1INT  Signal1 = "INT"
	Signal1KILL Signal1 = "KILL"
	Signal1QUIT Signal1 = "QUIT"
	Signal1STOP Signal1 = "STOP"
	Signal1TERM Signal1 = "TERM"
	Signal1TSTP Signal1 = "TSTP"
	Signal1TTIN Signal1 = "TTIN"
	Signal1TTOU Signal1 = "TTOU"
	Signal1URG  Signal1 = "URG"
	Signal1USR1 Signal1 = "USR1"
	Signal1USR2 Signal1 = "USR2"
)

// Defines values for V0036JobPropertiesExclusive.
const (
	V0036JobPropertiesExclusiveFalse V0036JobPropertiesExclusive = "false"
	V0036JobPropertiesExclusiveMcs   V0036JobPropertiesExclusive = "mcs"
	V0036JobPropertiesExclusiveTrue  V0036JobPropertiesExclusive = "true"
	V0036JobPropertiesExclusiveUser  V0036JobPropertiesExclusive = "user"
)

// Defines values for V0036JobPropertiesGresFlags.
const (
	V0036JobPropertiesGresFlagsDisableBinding V0036JobPropertiesGresFlags = "disable-binding"
	V0036JobPropertiesGresFlagsEnforceBinding V0036JobPropertiesGresFlags = "enforce-binding"
)

// Defines values for V0036JobPropertiesOpenMode.
const (
	V0036JobPropertiesOpenModeAppend   V0036JobPropertiesOpenMode = "append"
	V0036JobPropertiesOpenModeTruncate V0036JobPropertiesOpenMode = "truncate"
)

// Defines values for V0036PingPing.
const (
	V0036PingPingDOWN V0036PingPing = "DOWN"
	V0036PingPingUP   V0036PingPing = "UP"
)

// Defines values for V0036Signal.
const (
	V0036SignalABRT V0036Signal = "ABRT"
	V0036SignalALRM V0036Signal = "ALRM"
	V0036SignalCONT V0036Signal = "CONT"
	V0036SignalHUP  V0036Signal = "HUP"
	V0036SignalINT  V0036Signal = "INT"
	V0036SignalKILL V0036Signal = "KILL"
	V0036SignalQUIT V0036Signal = "QUIT"
	V0036SignalSTOP V0036Signal = "STOP"
	V0036SignalTERM V0036Signal = "TERM"
	V0036SignalTSTP V0036Signal = "TSTP"
	V0036SignalTTIN V0036Signal = "TTIN"
	V0036SignalTTOU V0036Signal = "TTOU"
	V0036SignalURG  V0036Signal = "URG"
	V0036SignalUSR1 V0036Signal = "USR1"
	V0036SignalUSR2 V0036Signal = "USR2"
)

// Defines values for V0037JobPropertiesExclusive.
const (
	False V0037JobPropertiesExclusive = "false"
	Mcs   V0037JobPropertiesExclusive = "mcs"
	True  V0037JobPropertiesExclusive = "true"
	User  V0037JobPropertiesExclusive = "user"
)

// Defines values for V0037JobPropertiesGresFlags.
const (
	DisableBinding V0037JobPropertiesGresFlags = "disable-binding"
	EnforceBinding V0037JobPropertiesGresFlags = "enforce-binding"
)

// Defines values for V0037JobPropertiesOpenMode.
const (
	Append   V0037JobPropertiesOpenMode = "append"
	Truncate V0037JobPropertiesOpenMode = "truncate"
)

// Defines values for V0037PingPing.
const (
	V0037PingPingDOWN V0037PingPing = "DOWN"
	V0037PingPingUP   V0037PingPing = "UP"
)

// Defines values for V0037Signal.
const (
	ABRT V0037Signal = "ABRT"
	ALRM V0037Signal = "ALRM"
	CONT V0037Signal = "CONT"
	HUP  V0037Signal = "HUP"
	INT  V0037Signal = "INT"
	KILL V0037Signal = "KILL"
	QUIT V0037Signal = "QUIT"
	STOP V0037Signal = "STOP"
	TERM V0037Signal = "TERM"
	TSTP V0037Signal = "TSTP"
	TTIN V0037Signal = "TTIN"
	TTOU V0037Signal = "TTOU"
	URG  V0037Signal = "URG"
	USR1 V0037Signal = "USR1"
	USR2 V0037Signal = "USR2"
)

// Dbv0036Account Account description
type Dbv0036Account struct {
	// Associations List of assigned associations
	Associations *[]Dbv0036AssociationShortInfo `json:"associations,omitempty"`

	// Coordinators List of assigned coordinators
	Coordinators *[]Dbv0036CoordinatorInfo `json:"coordinators,omitempty"`

	// Description Description of account
	Description *string `json:"description,omitempty"`

	// Flags List of properties of account
	Flags *[]string `json:"flags,omitempty"`

	// Name Name of account
	Name *string `json:"name,omitempty"`

	// Organization Assigned organization of account
	Organization *string `json:"organization,omitempty"`
}

// Dbv0036AccountInfo defines model for dbv0.0.36_account_info.
type Dbv0036AccountInfo struct {
	// Accounts List of accounts
	Accounts *[]Dbv0036Account `json:"accounts,omitempty"`

	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036AccountResponse defines model for dbv0.0.36_account_response.
type Dbv0036AccountResponse struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036Association Association description
type Dbv0036Association struct {
	// Account Assigned account
	Account *string `json:"account,omitempty"`

	// Cluster Assigned cluster
	Cluster *string `json:"cluster,omitempty"`

	// Default Default settings
	Default *struct {
		// Qos Default QOS
		Qos *string `json:"qos,omitempty"`
	} `json:"default,omitempty"`

	// Flags List of properties of association
	Flags *[]string `json:"flags,omitempty"`

	// Max Max settings
	Max *struct {
		// Jobs Max jobs settings
		Jobs *struct {
			// Per Max jobs per settings
			Per *struct {
				// WallClock Max wallclock per job
				WallClock *int `json:"wall_clock,omitempty"`
			} `json:"per,omitempty"`
		} `json:"jobs,omitempty"`

		// Per Max per settings
		Per *struct {
			// Account Max per accounting settings
			Account *struct {
				// WallClock Max wallclock per account
				WallClock *int `json:"wall_clock,omitempty"`
			} `json:"account,omitempty"`
		} `json:"per,omitempty"`

		// Tres Max TRES settings
		Tres *struct {
			// Minutes Max TRES minutes settings
			Minutes *struct {
				// Per Max TRES minutes per settings
				Per *struct {
					// Job TRES list of attributes
					Job *Dbv0036TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`

				// Total TRES list of attributes
				Total *Dbv0036TresList `json:"total,omitempty"`
			} `json:"minutes,omitempty"`

			// Per Max TRES per settings
			Per *struct {
				// Job TRES list of attributes
				Job *Dbv0036TresList `json:"job,omitempty"`

				// Node TRES list of attributes
				Node *Dbv0036TresList `json:"node,omitempty"`
			} `json:"per,omitempty"`

			// Total TRES list of attributes
			Total *Dbv0036TresList `json:"total,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"max,omitempty"`

	// Min Min settings
	Min *struct {
		// PriorityThreshold Min priority threshold
		PriorityThreshold *int `json:"priority_threshold,omitempty"`
	} `json:"min,omitempty"`

	// ParentAccount Parent account name
	ParentAccount *string `json:"parent_account,omitempty"`

	// Partition Assigned partition
	Partition *string `json:"partition,omitempty"`

	// Priority Assigned priority
	Priority *int `json:"priority,omitempty"`

	// Qos Assigned QOS
	Qos *[]string `json:"qos,omitempty"`

	// SharesRaw Raw fairshare shares
	SharesRaw *int `json:"shares_raw,omitempty"`

	// Usage Association usage
	Usage *struct {
		// AccrueJobCount Jobs accuring priority
		AccrueJobCount *int `json:"accrue_job_count,omitempty"`

		// EffectiveNormalizedUsage Effective normalized usage
		EffectiveNormalizedUsage *float32 `json:"effective_normalized_usage,omitempty"`

		// FairshareFactor Fairshare factor
		FairshareFactor *float32 `json:"fairshare_factor,omitempty"`

		// FairshareLevel Fairshare level
		FairshareLevel *float32 `json:"fairshare_level,omitempty"`

		// FairshareShares Fairshare shares
		FairshareShares *int `json:"fairshare_shares,omitempty"`

		// GroupUsedWallclock Group used wallclock time (s)
		GroupUsedWallclock *float32 `json:"group_used_wallclock,omitempty"`

		// JobCount Total jobs submitted
		JobCount *int `json:"job_count,omitempty"`

		// NormalizedPriority Currently active jobs
		NormalizedPriority *int `json:"normalized_priority,omitempty"`

		// NormalizedShares Normalized shares
		NormalizedShares *float32 `json:"normalized_shares,omitempty"`

		// RawUsage Raw usage
		RawUsage *int `json:"raw_usage,omitempty"`
	} `json:"usage,omitempty"`

	// User Assigned user
	User *string `json:"user,omitempty"`
}

// Dbv0036AssociationShortInfo defines model for dbv0.0.36_association_short_info.
type Dbv0036AssociationShortInfo struct {
	// Account Account name
	Account *string `json:"account,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Partition Partition name (optional)
	Partition *string `json:"partition,omitempty"`

	// User User name
	User *string `json:"user,omitempty"`
}

// Dbv0036AssociationsInfo defines model for dbv0.0.36_associations_info.
type Dbv0036AssociationsInfo struct {
	// Associations Array of associations
	Associations *[]Dbv0036Association `json:"associations,omitempty"`

	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ClusterInfo defines model for dbv0.0.36_cluster_info.
type Dbv0036ClusterInfo struct {
	// Associations Information about associations
	Associations *struct {
		Root *Dbv0036AssociationShortInfo `json:"root,omitempty"`
	} `json:"associations,omitempty"`

	// Controller Information about controller
	Controller *struct {
		// Host Hostname
		Host *string `json:"host,omitempty"`

		// Port Port number
		Port *int `json:"port,omitempty"`
	} `json:"controller,omitempty"`

	// Flags List of properties of cluster
	Flags *[]string `json:"flags,omitempty"`

	// Name Cluster name
	Name *string `json:"name,omitempty"`

	// Nodes Assigned nodes
	Nodes *string `json:"nodes,omitempty"`

	// RpcVersion Number rpc version
	RpcVersion *int `json:"rpc_version,omitempty"`

	// SelectPlugin Configured select plugin
	SelectPlugin *string `json:"select_plugin,omitempty"`

	// Tres List of TRES in cluster
	Tres *[]Dbv0036ResponseTres `json:"tres,omitempty"`
}

// Dbv0036ConfigInfo defines model for dbv0.0.36_config_info.
type Dbv0036ConfigInfo struct {
	// Accounts Array of accounts
	Accounts *[]Dbv0036Account `json:"accounts,omitempty"`

	// Associations Array of associations
	Associations *[]Dbv0036Association `json:"associations,omitempty"`

	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`

	// Qos Array of qos
	Qos *[]Dbv0036Qos `json:"qos,omitempty"`

	// Tres Array of TRES
	Tres *[]Dbv0036TresList `json:"tres,omitempty"`

	// Users Array of users
	Users *[]Dbv0036User `json:"users,omitempty"`

	// Wckeys Array of wckeys
	Wckeys *[]Dbv0036Wckey `json:"wckeys,omitempty"`
}

// Dbv0036ConfigResponse defines model for dbv0.0.36_config_response.
type Dbv0036ConfigResponse struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036CoordinatorInfo defines model for dbv0.0.36_coordinator_info.
type Dbv0036CoordinatorInfo struct {
	// Direct If user is coordinator of this account directly or coordinator status was inheirted from a higher account in the tree
	Direct *int `json:"direct,omitempty"`

	// Name Name of user
	Name *string `json:"name,omitempty"`
}

// Dbv0036Diag defines model for dbv0.0.36_diag.
type Dbv0036Diag struct {
	RPCs *[]struct {
		// Count Number of RPCs
		Count *int `json:"count,omitempty"`

		// Rpc RPC type
		Rpc *string `json:"rpc,omitempty"`

		// Time Time values
		Time *struct {
			// Average Average time spent processing this RPC type
			Average *int `json:"average,omitempty"`

			// Total Total time spent processing this RPC type
			Total *int `json:"total,omitempty"`
		} `json:"time,omitempty"`
	} `json:"RPCs,omitempty"`

	// Errors Slurm errors
	Errors  *[]Dbv0036Error `json:"errors,omitempty"`
	Rollups *[]struct {
		// LastCycle Timestamp of last cycle
		LastCycle *int `json:"last_cycle,omitempty"`

		// LastRun Timestamp of last rollup
		LastRun *int `json:"last_run,omitempty"`

		// MaxCycle Max time of all cycles
		MaxCycle *int `json:"max_cycle,omitempty"`

		// MeanCycles Average time (s) of cycle
		MeanCycles *int `json:"mean_cycles,omitempty"`

		// TotalTime Total time (s) spent doing rollup
		TotalTime *int `json:"total_time,omitempty"`

		// Type Type of rollup
		Type *string `json:"type,omitempty"`
	} `json:"rollups,omitempty"`

	// TimeStart Unix timestamp of start time
	TimeStart *int `json:"time_start,omitempty"`
	Users     *[]struct {
		// Count Number of RPCs
		Count *int `json:"count,omitempty"`

		// Time Time values
		Time *struct {
			// Average Average time spent processing each user RPC
			Average *int `json:"average,omitempty"`

			// Total Total time spent processing each user RPC
			Total *int `json:"total,omitempty"`
		} `json:"time,omitempty"`

		// User User name
		User *string `json:"user,omitempty"`
	} `json:"users,omitempty"`
}

// Dbv0036Error defines model for dbv0.0.36_error.
type Dbv0036Error struct {
	// Errno Error number
	Errno *int `json:"errno,omitempty"`

	// Error Error message
	Error *string `json:"error,omitempty"`
}

// Dbv0036Job Single job description
type Dbv0036Job struct {
	// Account Account charged by job
	Account *string `json:"account,omitempty"`

	// AllocationNodes Nodes allocated to job
	AllocationNodes *string `json:"allocation_nodes,omitempty"`

	// Array Array properties (optional)
	Array *struct {
		// JobId Job id of array
		JobId *int `json:"job_id,omitempty"`

		// Limits Limits on array settings
		Limits *struct {
			// Max Limits on array settings
			Max *struct {
				// Running Limits on array settings
				Running *struct {
					// Tasks Max running tasks in array at any one time
					Tasks *int `json:"tasks,omitempty"`
				} `json:"running,omitempty"`
			} `json:"max,omitempty"`
		} `json:"limits,omitempty"`

		// Task Array task
		Task *string `json:"task,omitempty"`

		// TaskId Array task id
		TaskId *int `json:"task_id,omitempty"`
	} `json:"array,omitempty"`
	Association *Dbv0036AssociationShortInfo `json:"association,omitempty"`

	// Cluster Assigned cluster
	Cluster *string `json:"cluster,omitempty"`

	// Comment Job comments by type
	Comment *struct {
		// Administrator Administrator set comment
		Administrator *string `json:"administrator,omitempty"`

		// Job Job comment
		Job *string `json:"job,omitempty"`

		// System System set comment
		System *string `json:"system,omitempty"`
	} `json:"comment,omitempty"`

	// Constraints Constraints on job
	Constraints     *string             `json:"constraints,omitempty"`
	DerivedExitCode *Dbv0036JobExitCode `json:"derived_exit_code,omitempty"`
	ExitCode        *Dbv0036JobExitCode `json:"exit_code,omitempty"`

	// Flags List of properties of job
	Flags *[]string `json:"flags,omitempty"`

	// Group User's group to run job
	Group *string `json:"group,omitempty"`

	// Het Heterogeneous Job details (optional)
	Het *struct {
		// JobId Parent HetJob id
		JobId *map[string]interface{} `json:"job_id,omitempty"`

		// JobOffset Offset of this job to parent
		JobOffset *map[string]interface{} `json:"job_offset,omitempty"`
	} `json:"het,omitempty"`

	// JobId Job id
	JobId *int `json:"job_id,omitempty"`

	// KillRequestUser User who requested job killed
	KillRequestUser *string `json:"kill_request_user,omitempty"`

	// Mcs Multi-Category Security
	Mcs *struct {
		// Label Assigned MCS label
		Label *string `json:"label,omitempty"`
	} `json:"mcs,omitempty"`

	// Name Assigned job name
	Name *string `json:"name,omitempty"`

	// Nodes List of nodes allocated for job
	Nodes *string `json:"nodes,omitempty"`

	// Partition Assigned job's partition
	Partition *string `json:"partition,omitempty"`

	// Priority Priority
	Priority *int `json:"priority,omitempty"`

	// Qos Assigned qos name
	Qos *string `json:"qos,omitempty"`

	// Required Job run requirements
	Required *struct {
		// CPUs Required number of CPUs
		CPUs *int `json:"CPUs,omitempty"`

		// Memory Required amount of memory (MiB)
		Memory *int `json:"memory,omitempty"`
	} `json:"required,omitempty"`

	// Reservation Reservation usage details
	Reservation *struct {
		// Id Database id of reservation
		Id *int `json:"id,omitempty"`

		// Name Name of reservation
		Name *int `json:"name,omitempty"`
	} `json:"reservation,omitempty"`

	// State State properties of job
	State *struct {
		// Current Current state of job
		Current *string `json:"current,omitempty"`

		// Previous Last reason job didn't run
		Previous *string `json:"previous,omitempty"`
	} `json:"state,omitempty"`

	// Steps Job step description
	Steps *[]Dbv0036JobStep `json:"steps,omitempty"`

	// Time Time properties
	Time *struct {
		// Elapsed Total time elapsed
		Elapsed *int `json:"elapsed,omitempty"`

		// Eligible Total time eligible to run
		Eligible *int `json:"eligible,omitempty"`

		// End Timestamp of when job ended
		End *int `json:"end,omitempty"`

		// Limit Job wall clock time limit
		Limit *int `json:"limit,omitempty"`

		// Start Timestamp of when job started
		Start *int `json:"start,omitempty"`

		// Submission Timestamp of when job submitted
		Submission *int `json:"submission,omitempty"`

		// Suspended Timestamp of when job last suspended
		Suspended *int `json:"suspended,omitempty"`

		// System System time values
		System *struct {
			// Microseconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"system,omitempty"`

		// Total System time values
		Total *struct {
			// Microseconds Total number of CPU-seconds used by the job, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"total,omitempty"`

		// User User land time values
		User *struct {
			// Microseconds Total number of CPU-seconds used by the job in user land, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job in user land, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`

	// Tres TRES settings
	Tres *struct {
		// Allocated TRES list of attributes
		Allocated *Dbv0036TresList `json:"allocated,omitempty"`

		// Requested TRES list of attributes
		Requested *Dbv0036TresList `json:"requested,omitempty"`
	} `json:"tres,omitempty"`

	// User Job user
	User *string `json:"user,omitempty"`

	// Wckey Job assigned wckey details
	Wckey *struct {
		// Flags wckey flags
		Flags *[]string `json:"flags,omitempty"`

		// Wckey Job assigned wckey
		Wckey *string `json:"wckey,omitempty"`
	} `json:"wckey,omitempty"`

	// WorkingDirectory Directory where job was initially started
	WorkingDirectory *string `json:"working_directory,omitempty"`
}

// Dbv0036JobExitCode defines model for dbv0.0.36_job_exit_code.
type Dbv0036JobExitCode struct {
	// ReturnCode Return code from parent process
	ReturnCode *int `json:"return_code,omitempty"`

	// Signal Signal details (if signaled)
	Signal *struct {
		// Name Name of signal received
		Name *string `json:"name,omitempty"`

		// SignalId Signal number process received
		SignalId *int `json:"signal_id,omitempty"`
	} `json:"signal,omitempty"`

	// Status Job exit status
	Status *string `json:"status,omitempty"`
}

// Dbv0036JobInfo defines model for dbv0.0.36_job_info.
type Dbv0036JobInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`

	// Jobs Array of jobs
	Jobs *[]Dbv0036Job `json:"jobs,omitempty"`
}

// Dbv0036JobStep defines model for dbv0.0.36_job_step.
type Dbv0036JobStep struct {
	// CPU CPU properties
	CPU *struct {
		// Governor CPU governor
		Governor *[]string `json:"governor,omitempty"`

		// RequestedFrequency CPU frequency requested
		RequestedFrequency *struct {
			// Max Max CPU frequency
			Max *int `json:"max,omitempty"`

			// Min Min CPU frequency
			Min *int `json:"min,omitempty"`
		} `json:"requested_frequency,omitempty"`
	} `json:"CPU,omitempty"`
	ExitCode *Dbv0036JobExitCode `json:"exit_code,omitempty"`

	// KillRequestUser User who requested job killed
	KillRequestUser *string `json:"kill_request_user,omitempty"`

	// Nodes Node details
	Nodes *struct {
		// Count Total number of nodes in step
		Count *int `json:"count,omitempty"`

		// Range Nodes in step
		Range *string `json:"range,omitempty"`
	} `json:"nodes,omitempty"`

	// Pid First process PID
	Pid *string `json:"pid,omitempty"`

	// State State of job step
	State *string `json:"state,omitempty"`

	// Statistics Statistics of job step
	Statistics *struct {
		// CPU Statistics of CPU
		CPU *struct {
			// ActualFrequency Actual frequency of CPU during step
			ActualFrequency *int `json:"actual_frequency,omitempty"`
		} `json:"CPU,omitempty"`

		// Energy Statistics of energy
		Energy *struct {
			// Consumed Energy consumed during step
			Consumed *int `json:"consumed,omitempty"`
		} `json:"energy,omitempty"`
	} `json:"statistics,omitempty"`

	// Step Step details
	Step *struct {
		// Het Heterogeneous job details
		Het *struct {
			// Component Parent HetJob component id
			Component *int `json:"component,omitempty"`
		} `json:"het,omitempty"`

		// Id Step id
		Id *string `json:"id,omitempty"`

		// JobId Parent job id
		JobId *int `json:"job_id,omitempty"`

		// Name Step name
		Name *string `json:"name,omitempty"`
	} `json:"step,omitempty"`

	// Task Task properties
	Task *struct {
		// Distribution Task distribution type
		Distribution *string `json:"distribution,omitempty"`
	} `json:"task,omitempty"`

	// Tasks Task properties
	Tasks *struct {
		// Count Number of tasks in step
		Count *int `json:"count,omitempty"`
	} `json:"tasks,omitempty"`

	// Time Time properties
	Time *struct {
		// Elapsed Total time elapsed
		Elapsed *int `json:"elapsed,omitempty"`

		// End Timestamp of when job ended
		End *int `json:"end,omitempty"`

		// Start Timestamp of when job started
		Start *int `json:"start,omitempty"`

		// Suspended Timestamp of when job last suspended
		Suspended *int `json:"suspended,omitempty"`

		// System System time values
		System *struct {
			// Microseconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"system,omitempty"`

		// Total System time values
		Total *struct {
			// Microseconds Total number of CPU-seconds used by the job, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"total,omitempty"`

		// User User land time values
		User *struct {
			// Microseconds Total number of CPU-seconds used by the job in user land, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job in user land, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`

	// Tres TRES usage
	Tres *struct {
		// Allocated TRES list of attributes
		Allocated *Dbv0036TresList `json:"allocated,omitempty"`

		// Consumed TRES requested for job
		Consumed *struct {
			// Average TRES list of attributes
			Average *Dbv0036TresList `json:"average,omitempty"`

			// Max TRES list of attributes
			Max *Dbv0036TresList `json:"max,omitempty"`

			// Min TRES list of attributes
			Min *Dbv0036TresList `json:"min,omitempty"`

			// Total TRES list of attributes
			Total *Dbv0036TresList `json:"total,omitempty"`
		} `json:"consumed,omitempty"`

		// Requested TRES requested for job
		Requested *struct {
			// Average TRES list of attributes
			Average *Dbv0036TresList `json:"average,omitempty"`

			// Max TRES list of attributes
			Max *Dbv0036TresList `json:"max,omitempty"`

			// Min TRES list of attributes
			Min *Dbv0036TresList `json:"min,omitempty"`

			// Total TRES list of attributes
			Total *Dbv0036TresList `json:"total,omitempty"`
		} `json:"requested,omitempty"`
	} `json:"tres,omitempty"`
}

// Dbv0036Qos QOS description
type Dbv0036Qos struct {
	// Description QOS description
	Description *string `json:"description,omitempty"`

	// Flags List of properties of QOS
	Flags *[]string `json:"flags,omitempty"`

	// Id Database id
	Id *string `json:"id,omitempty"`

	// Limits Assigned limits
	Limits *struct {
		// Max Limits on max settings
		Max *struct {
			// Accruing Limits on accruing priority
			Accruing *struct {
				// Per Max accuring priority per setting
				Per *struct {
					// Account Max accuring priority per account
					Account *int `json:"account,omitempty"`

					// User Max accuring priority per user
					User *int `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"accruing,omitempty"`

			// Jobs Limits on jobs settings
			Jobs *struct {
				// Per Limits on jobs per settings
				Per *struct {
					// Account Max jobs per account
					Account *int `json:"account,omitempty"`

					// User Max jobs per user
					User *int `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"jobs,omitempty"`

			// Tres Limits on TRES
			Tres *struct {
				// Minutes Max TRES minutes settings
				Minutes *struct {
					// Per Max TRES minutes per settings
					Per *struct {
						// Account TRES list of attributes
						Account *Dbv0036TresList `json:"account,omitempty"`

						// Job TRES list of attributes
						Job *Dbv0036TresList `json:"job,omitempty"`

						// User TRES list of attributes
						User *Dbv0036TresList `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"minutes,omitempty"`

				// Per Max TRES per settings
				Per *struct {
					// Account TRES list of attributes
					Account *Dbv0036TresList `json:"account,omitempty"`

					// Job TRES list of attributes
					Job *Dbv0036TresList `json:"job,omitempty"`

					// Node TRES list of attributes
					Node *Dbv0036TresList `json:"node,omitempty"`

					// User TRES list of attributes
					User *Dbv0036TresList `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"tres,omitempty"`

			// WallClock Limit on wallclock settings
			WallClock *struct {
				// Per Limit on wallclock per settings
				Per *struct {
					// Job Max wallclock per job
					Job *int `json:"job,omitempty"`

					// Qos Max wallclock per QOS
					Qos *int `json:"qos,omitempty"`
				} `json:"per,omitempty"`
			} `json:"wall_clock,omitempty"`
		} `json:"max,omitempty"`

		// Min Min limit settings
		Min *struct {
			// PriorityThreshold Min priority threshold
			PriorityThreshold *int `json:"priority_threshold,omitempty"`

			// Tres Min tres settings
			Tres *struct {
				// Per Min tres per settings
				Per *struct {
					// Job TRES list of attributes
					Job *Dbv0036TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"min,omitempty"`
	} `json:"limits,omitempty"`

	// Preempt Preemption settings
	Preempt *struct {
		// ExemptTime Grace period (s) before jobs can preempted
		ExemptTime *int `json:"exempt_time,omitempty"`

		// List List of preemptable QOS
		List *[]string `json:"list,omitempty"`

		// Mode List of preemption modes
		Mode *[]string `json:"mode,omitempty"`
	} `json:"preempt,omitempty"`

	// Priority QOS priority
	Priority *int `json:"priority,omitempty"`

	// UsageFactor Usage factor
	UsageFactor *float32 `json:"usage_factor,omitempty"`

	// UsageThreshold Usage threshold
	UsageThreshold *float32 `json:"usage_threshold,omitempty"`
}

// Dbv0036QosInfo defines model for dbv0.0.36_qos_info.
type Dbv0036QosInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`

	// Qos Array of QOS
	Qos *[]Dbv0036Qos `json:"qos,omitempty"`
}

// Dbv0036ResponseAccountDelete defines model for dbv0.0.36_response_account_delete.
type Dbv0036ResponseAccountDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseAssociationDelete defines model for dbv0.0.36_response_association_delete.
type Dbv0036ResponseAssociationDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseClusterAdd defines model for dbv0.0.36_response_cluster_add.
type Dbv0036ResponseClusterAdd struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseClusterDelete defines model for dbv0.0.36_response_cluster_delete.
type Dbv0036ResponseClusterDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseQosDelete defines model for dbv0.0.36_response_qos_delete.
type Dbv0036ResponseQosDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseTres defines model for dbv0.0.36_response_tres.
type Dbv0036ResponseTres struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseUserDelete defines model for dbv0.0.36_response_user_delete.
type Dbv0036ResponseUserDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseUserUpdate defines model for dbv0.0.36_response_user_update.
type Dbv0036ResponseUserUpdate struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseWckeyAdd defines model for dbv0.0.36_response_wckey_add.
type Dbv0036ResponseWckeyAdd struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036ResponseWckeyDelete defines model for dbv0.0.36_response_wckey_delete.
type Dbv0036ResponseWckeyDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`
}

// Dbv0036TresInfo defines model for dbv0.0.36_tres_info.
type Dbv0036TresInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`

	// Tres Array of tres
	Tres *[]Dbv0036TresList `json:"tres,omitempty"`
}

// Dbv0036TresList TRES list of attributes
type Dbv0036TresList = []struct {
	// Count count of TRES
	Count *int `json:"count,omitempty"`

	// Id database id
	Id *int `json:"id,omitempty"`

	// Name TRES name (optional)
	Name *string `json:"name,omitempty"`

	// Type TRES type
	Type *string `json:"type,omitempty"`
}

// Dbv0036User User description
type Dbv0036User struct {
	// AdministratorLevel Description of administrator level
	AdministratorLevel *string `json:"administrator_level,omitempty"`

	// Associations Assigned associations
	Associations *struct {
		Root *Dbv0036AssociationShortInfo `json:"root,omitempty"`
	} `json:"associations,omitempty"`

	// Coordinators List of assigned coordinators
	Coordinators *[]Dbv0036CoordinatorInfo `json:"coordinators,omitempty"`

	// Default Default settings
	Default *struct {
		// Account Default account name
		Account *string `json:"account,omitempty"`

		// Wckey Default wckey
		Wckey *string `json:"wckey,omitempty"`
	} `json:"default,omitempty"`

	// Name User name
	Name *string `json:"name,omitempty"`
}

// Dbv0036UserInfo defines model for dbv0.0.36_user_info.
type Dbv0036UserInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`

	// Users Array of users
	Users *[]Dbv0036User `json:"users,omitempty"`
}

// Dbv0036Wckey defines model for dbv0.0.36_wckey.
type Dbv0036Wckey struct {
	// Accounts List of assigned accounts
	Accounts *[]string `json:"accounts,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Flags List of properties of wckey
	Flags *[]string `json:"flags,omitempty"`

	// Id wckey database unique id
	Id *int `json:"id,omitempty"`

	// Name wckey name
	Name *string `json:"name,omitempty"`

	// User wckey user
	User *string `json:"user,omitempty"`
}

// Dbv0036WckeyInfo defines model for dbv0.0.36_wckey_info.
type Dbv0036WckeyInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0036Error `json:"errors,omitempty"`

	// Wckeys List of wckeys
	Wckeys *[]Dbv0036Wckey `json:"wckeys,omitempty"`
}

// Dbv0037Account Account description
type Dbv0037Account struct {
	// Associations List of assigned associations
	Associations *[]Dbv0037AssociationShortInfo `json:"associations,omitempty"`

	// Coordinators List of assigned coordinators
	Coordinators *[]Dbv0037CoordinatorInfo `json:"coordinators,omitempty"`

	// Description Description of account
	Description *string `json:"description,omitempty"`

	// Flags List of properties of account
	Flags *[]string `json:"flags,omitempty"`

	// Name Name of account
	Name *string `json:"name,omitempty"`

	// Organization Assigned organization of account
	Organization *string `json:"organization,omitempty"`
}

// Dbv0037AccountInfo defines model for dbv0.0.37_account_info.
type Dbv0037AccountInfo struct {
	// Accounts List of accounts
	Accounts *[]Dbv0037Account `json:"accounts,omitempty"`

	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037AccountResponse defines model for dbv0.0.37_account_response.
type Dbv0037AccountResponse struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037Association Association description
type Dbv0037Association struct {
	// Account Assigned account
	Account *string `json:"account,omitempty"`

	// Cluster Assigned cluster
	Cluster *string `json:"cluster,omitempty"`

	// Default Default settings
	Default *struct {
		// Qos Default QOS
		Qos *string `json:"qos,omitempty"`
	} `json:"default,omitempty"`

	// Flags List of properties of association
	Flags *[]string `json:"flags,omitempty"`

	// Max Max settings
	Max *struct {
		// Jobs Max jobs settings
		Jobs *struct {
			// Per Max jobs per settings
			Per *struct {
				// WallClock Max wallclock per job
				WallClock *int `json:"wall_clock,omitempty"`
			} `json:"per,omitempty"`
		} `json:"jobs,omitempty"`

		// Per Max per settings
		Per *struct {
			// Account Max per accounting settings
			Account *struct {
				// WallClock Max wallclock per account
				WallClock *int `json:"wall_clock,omitempty"`
			} `json:"account,omitempty"`
		} `json:"per,omitempty"`

		// Tres Max TRES settings
		Tres *struct {
			// Minutes Max TRES minutes settings
			Minutes *struct {
				// Per Max TRES minutes per settings
				Per *struct {
					// Job TRES list of attributes
					Job *Dbv0037TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`

				// Total TRES list of attributes
				Total *Dbv0037TresList `json:"total,omitempty"`
			} `json:"minutes,omitempty"`

			// Per Max TRES per settings
			Per *struct {
				// Job TRES list of attributes
				Job *Dbv0037TresList `json:"job,omitempty"`

				// Node TRES list of attributes
				Node *Dbv0037TresList `json:"node,omitempty"`
			} `json:"per,omitempty"`

			// Total TRES list of attributes
			Total *Dbv0037TresList `json:"total,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"max,omitempty"`

	// Min Min settings
	Min *struct {
		// PriorityThreshold Min priority threshold
		PriorityThreshold *int `json:"priority_threshold,omitempty"`
	} `json:"min,omitempty"`

	// ParentAccount Parent account name
	ParentAccount *string `json:"parent_account,omitempty"`

	// Partition Assigned partition
	Partition *string `json:"partition,omitempty"`

	// Priority Assigned priority
	Priority *int `json:"priority,omitempty"`

	// Qos Assigned QOS
	Qos *[]string `json:"qos,omitempty"`

	// SharesRaw Raw fairshare shares
	SharesRaw *int `json:"shares_raw,omitempty"`

	// Usage Association usage
	Usage *struct {
		// AccrueJobCount Jobs accuring priority
		AccrueJobCount *int `json:"accrue_job_count,omitempty"`

		// EffectiveNormalizedUsage Effective normalized usage
		EffectiveNormalizedUsage *float32 `json:"effective_normalized_usage,omitempty"`

		// FairshareFactor Fairshare factor
		FairshareFactor *float32 `json:"fairshare_factor,omitempty"`

		// FairshareLevel Fairshare level
		FairshareLevel *float32 `json:"fairshare_level,omitempty"`

		// FairshareShares Fairshare shares
		FairshareShares *int `json:"fairshare_shares,omitempty"`

		// GroupUsedWallclock Group used wallclock time (s)
		GroupUsedWallclock *float32 `json:"group_used_wallclock,omitempty"`

		// JobCount Total jobs submitted
		JobCount *int `json:"job_count,omitempty"`

		// NormalizedPriority Currently active jobs
		NormalizedPriority *int `json:"normalized_priority,omitempty"`

		// NormalizedShares Normalized shares
		NormalizedShares *float32 `json:"normalized_shares,omitempty"`

		// RawUsage Raw usage
		RawUsage *int `json:"raw_usage,omitempty"`
	} `json:"usage,omitempty"`

	// User Assigned user
	User *string `json:"user,omitempty"`
}

// Dbv0037AssociationShortInfo defines model for dbv0.0.37_association_short_info.
type Dbv0037AssociationShortInfo struct {
	// Account Account name
	Account *string `json:"account,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Partition Partition name (optional)
	Partition *string `json:"partition,omitempty"`

	// User User name
	User *string `json:"user,omitempty"`
}

// Dbv0037AssociationsInfo defines model for dbv0.0.37_associations_info.
type Dbv0037AssociationsInfo struct {
	// Associations Array of associations
	Associations *[]Dbv0037Association `json:"associations,omitempty"`

	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ClusterInfo defines model for dbv0.0.37_cluster_info.
type Dbv0037ClusterInfo struct {
	// Associations Information about associations
	Associations *struct {
		Root *Dbv0037AssociationShortInfo `json:"root,omitempty"`
	} `json:"associations,omitempty"`

	// Controller Information about controller
	Controller *struct {
		// Host Hostname
		Host *string `json:"host,omitempty"`

		// Port Port number
		Port *int `json:"port,omitempty"`
	} `json:"controller,omitempty"`

	// Flags List of properties of cluster
	Flags *[]string `json:"flags,omitempty"`

	// Name Cluster name
	Name *string `json:"name,omitempty"`

	// Nodes Assigned nodes
	Nodes *string `json:"nodes,omitempty"`

	// RpcVersion Number rpc version
	RpcVersion *int `json:"rpc_version,omitempty"`

	// SelectPlugin Configured select plugin
	SelectPlugin *string `json:"select_plugin,omitempty"`

	// Tres List of TRES in cluster
	Tres *[]Dbv0037ResponseTres `json:"tres,omitempty"`
}

// Dbv0037ConfigInfo defines model for dbv0.0.37_config_info.
type Dbv0037ConfigInfo struct {
	// Accounts Array of accounts
	Accounts *[]Dbv0037Account `json:"accounts,omitempty"`

	// Associations Array of associations
	Associations *[]Dbv0037Association `json:"associations,omitempty"`

	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`

	// Qos Array of qos
	Qos *[]Dbv0037Qos `json:"qos,omitempty"`

	// Tres Array of TRES
	Tres *[]Dbv0037TresList `json:"tres,omitempty"`

	// Users Array of users
	Users *[]Dbv0037User `json:"users,omitempty"`

	// Wckeys Array of wckeys
	Wckeys *[]Dbv0037Wckey `json:"wckeys,omitempty"`
}

// Dbv0037ConfigResponse defines model for dbv0.0.37_config_response.
type Dbv0037ConfigResponse struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037CoordinatorInfo defines model for dbv0.0.37_coordinator_info.
type Dbv0037CoordinatorInfo struct {
	// Direct If user is coordinator of this account directly or coordinator status was inheirted from a higher account in the tree
	Direct *int `json:"direct,omitempty"`

	// Name Name of user
	Name *string `json:"name,omitempty"`
}

// Dbv0037Diag defines model for dbv0.0.37_diag.
type Dbv0037Diag struct {
	RPCs *[]struct {
		// Count Number of RPCs
		Count *int `json:"count,omitempty"`

		// Rpc RPC type
		Rpc *string `json:"rpc,omitempty"`

		// Time Time values
		Time *struct {
			// Average Average time spent processing this RPC type
			Average *int `json:"average,omitempty"`

			// Total Total time spent processing this RPC type
			Total *int `json:"total,omitempty"`
		} `json:"time,omitempty"`
	} `json:"RPCs,omitempty"`

	// Errors Slurm errors
	Errors  *[]Dbv0037Error `json:"errors,omitempty"`
	Rollups *[]struct {
		// LastCycle Timestamp of last cycle
		LastCycle *int `json:"last_cycle,omitempty"`

		// LastRun Timestamp of last rollup
		LastRun *int `json:"last_run,omitempty"`

		// MaxCycle Max time of all cycles
		MaxCycle *int `json:"max_cycle,omitempty"`

		// MeanCycles Average time (s) of cycle
		MeanCycles *int `json:"mean_cycles,omitempty"`

		// TotalTime Total time (s) spent doing rollup
		TotalTime *int `json:"total_time,omitempty"`

		// Type Type of rollup
		Type *string `json:"type,omitempty"`
	} `json:"rollups,omitempty"`

	// TimeStart Unix timestamp of start time
	TimeStart *int `json:"time_start,omitempty"`
	Users     *[]struct {
		// Count Number of RPCs
		Count *int `json:"count,omitempty"`

		// Time Time values
		Time *struct {
			// Average Average time spent processing each user RPC
			Average *int `json:"average,omitempty"`

			// Total Total time spent processing each user RPC
			Total *int `json:"total,omitempty"`
		} `json:"time,omitempty"`

		// User User name
		User *string `json:"user,omitempty"`
	} `json:"users,omitempty"`
}

// Dbv0037Error defines model for dbv0.0.37_error.
type Dbv0037Error struct {
	// Errno Error number
	Errno *int `json:"errno,omitempty"`

	// Error Error message
	Error *string `json:"error,omitempty"`
}

// Dbv0037Job Single job description
type Dbv0037Job struct {
	// Account Account charged by job
	Account *string `json:"account,omitempty"`

	// AllocationNodes Nodes allocated to job
	AllocationNodes *string `json:"allocation_nodes,omitempty"`

	// Array Array properties (optional)
	Array *struct {
		// JobId Job id of array
		JobId *int `json:"job_id,omitempty"`

		// Limits Limits on array settings
		Limits *struct {
			// Max Limits on array settings
			Max *struct {
				// Running Limits on array settings
				Running *struct {
					// Tasks Max running tasks in array at any one time
					Tasks *int `json:"tasks,omitempty"`
				} `json:"running,omitempty"`
			} `json:"max,omitempty"`
		} `json:"limits,omitempty"`

		// Task Array task
		Task *string `json:"task,omitempty"`

		// TaskId Array task id
		TaskId *int `json:"task_id,omitempty"`
	} `json:"array,omitempty"`
	Association *Dbv0037AssociationShortInfo `json:"association,omitempty"`

	// Cluster Assigned cluster
	Cluster *string `json:"cluster,omitempty"`

	// Comment Job comments by type
	Comment *struct {
		// Administrator Administrator set comment
		Administrator *string `json:"administrator,omitempty"`

		// Job Job comment
		Job *string `json:"job,omitempty"`

		// System System set comment
		System *string `json:"system,omitempty"`
	} `json:"comment,omitempty"`

	// Constraints Constraints on job
	Constraints     *string             `json:"constraints,omitempty"`
	DerivedExitCode *Dbv0037JobExitCode `json:"derived_exit_code,omitempty"`
	ExitCode        *Dbv0037JobExitCode `json:"exit_code,omitempty"`

	// Flags List of properties of job
	Flags *[]string `json:"flags,omitempty"`

	// Group User's group to run job
	Group *string `json:"group,omitempty"`

	// Het Heterogeneous Job details (optional)
	Het *struct {
		// JobId Parent HetJob id
		JobId *map[string]interface{} `json:"job_id,omitempty"`

		// JobOffset Offset of this job to parent
		JobOffset *map[string]interface{} `json:"job_offset,omitempty"`
	} `json:"het,omitempty"`

	// JobId Job id
	JobId *int `json:"job_id,omitempty"`

	// KillRequestUser User who requested job killed
	KillRequestUser *string `json:"kill_request_user,omitempty"`

	// Mcs Multi-Category Security
	Mcs *struct {
		// Label Assigned MCS label
		Label *string `json:"label,omitempty"`
	} `json:"mcs,omitempty"`

	// Name Assigned job name
	Name *string `json:"name,omitempty"`

	// Nodes List of nodes allocated for job
	Nodes *string `json:"nodes,omitempty"`

	// Partition Assigned job's partition
	Partition *string `json:"partition,omitempty"`

	// Priority Priority
	Priority *int `json:"priority,omitempty"`

	// Qos Assigned qos name
	Qos *string `json:"qos,omitempty"`

	// Required Job run requirements
	Required *struct {
		// CPUs Required number of CPUs
		CPUs *int `json:"CPUs,omitempty"`

		// Memory Required amount of memory (MiB)
		Memory *int `json:"memory,omitempty"`
	} `json:"required,omitempty"`

	// Reservation Reservation usage details
	Reservation *struct {
		// Id Database id of reservation
		Id *int `json:"id,omitempty"`

		// Name Name of reservation
		Name *int `json:"name,omitempty"`
	} `json:"reservation,omitempty"`

	// State State properties of job
	State *struct {
		// Current Current state of job
		Current *string `json:"current,omitempty"`

		// Reason Last reason job didn't run
		Reason *string `json:"reason,omitempty"`
	} `json:"state,omitempty"`

	// Steps Job step description
	Steps *[]Dbv0037JobStep `json:"steps,omitempty"`

	// Time Time properties
	Time *struct {
		// Elapsed Total time elapsed
		Elapsed *int `json:"elapsed,omitempty"`

		// Eligible Total time eligible to run
		Eligible *int `json:"eligible,omitempty"`

		// End Timestamp of when job ended
		End *int `json:"end,omitempty"`

		// Limit Job wall clock time limit
		Limit *int `json:"limit,omitempty"`

		// Start Timestamp of when job started
		Start *int `json:"start,omitempty"`

		// Submission Timestamp of when job submitted
		Submission *int `json:"submission,omitempty"`

		// Suspended Timestamp of when job last suspended
		Suspended *int `json:"suspended,omitempty"`

		// System System time values
		System *struct {
			// Microseconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"system,omitempty"`

		// Total System time values
		Total *struct {
			// Microseconds Total number of CPU-seconds used by the job, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"total,omitempty"`

		// User User land time values
		User *struct {
			// Microseconds Total number of CPU-seconds used by the job in user land, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job in user land, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`

	// Tres TRES settings
	Tres *struct {
		// Allocated TRES list of attributes
		Allocated *Dbv0037TresList `json:"allocated,omitempty"`

		// Requested TRES list of attributes
		Requested *Dbv0037TresList `json:"requested,omitempty"`
	} `json:"tres,omitempty"`

	// User Job user
	User *string `json:"user,omitempty"`

	// Wckey Job assigned wckey details
	Wckey *struct {
		// Flags wckey flags
		Flags *[]string `json:"flags,omitempty"`

		// Wckey Job assigned wckey
		Wckey *string `json:"wckey,omitempty"`
	} `json:"wckey,omitempty"`

	// WorkingDirectory Directory where job was initially started
	WorkingDirectory *string `json:"working_directory,omitempty"`
}

// Dbv0037JobExitCode defines model for dbv0.0.37_job_exit_code.
type Dbv0037JobExitCode struct {
	// ReturnCode Return code from parent process
	ReturnCode *int `json:"return_code,omitempty"`

	// Signal Signal details (if signaled)
	Signal *struct {
		// Name Name of signal received
		Name *string `json:"name,omitempty"`

		// SignalId Signal number process received
		SignalId *int `json:"signal_id,omitempty"`
	} `json:"signal,omitempty"`

	// Status Job exit status
	Status *string `json:"status,omitempty"`
}

// Dbv0037JobInfo defines model for dbv0.0.37_job_info.
type Dbv0037JobInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`

	// Jobs Array of jobs
	Jobs *[]Dbv0037Job `json:"jobs,omitempty"`
}

// Dbv0037JobStep defines model for dbv0.0.37_job_step.
type Dbv0037JobStep struct {
	// CPU CPU properties
	CPU *struct {
		// Governor CPU governor
		Governor *[]string `json:"governor,omitempty"`

		// RequestedFrequency CPU frequency requested
		RequestedFrequency *struct {
			// Max Max CPU frequency
			Max *int `json:"max,omitempty"`

			// Min Min CPU frequency
			Min *int `json:"min,omitempty"`
		} `json:"requested_frequency,omitempty"`
	} `json:"CPU,omitempty"`
	ExitCode *Dbv0037JobExitCode `json:"exit_code,omitempty"`

	// KillRequestUser User who requested job killed
	KillRequestUser *string `json:"kill_request_user,omitempty"`

	// Nodes Node details
	Nodes *struct {
		// Count Total number of nodes in step
		Count *int `json:"count,omitempty"`

		// Range Nodes in step
		Range *string `json:"range,omitempty"`
	} `json:"nodes,omitempty"`

	// Pid First process PID
	Pid *string `json:"pid,omitempty"`

	// State State of job step
	State *string `json:"state,omitempty"`

	// Statistics Statistics of job step
	Statistics *struct {
		// CPU Statistics of CPU
		CPU *struct {
			// ActualFrequency Actual frequency of CPU during step
			ActualFrequency *int `json:"actual_frequency,omitempty"`
		} `json:"CPU,omitempty"`

		// Energy Statistics of energy
		Energy *struct {
			// Consumed Energy consumed during step
			Consumed *int `json:"consumed,omitempty"`
		} `json:"energy,omitempty"`
	} `json:"statistics,omitempty"`

	// Step Step details
	Step *struct {
		// Het Heterogeneous job details
		Het *struct {
			// Component Parent HetJob component id
			Component *int `json:"component,omitempty"`
		} `json:"het,omitempty"`

		// Id Step id
		Id *string `json:"id,omitempty"`

		// JobId Parent job id
		JobId *int `json:"job_id,omitempty"`

		// Name Step name
		Name *string `json:"name,omitempty"`
	} `json:"step,omitempty"`

	// Task Task properties
	Task *struct {
		// Distribution Task distribution type
		Distribution *string `json:"distribution,omitempty"`
	} `json:"task,omitempty"`

	// Tasks Task properties
	Tasks *struct {
		// Count Number of tasks in step
		Count *int `json:"count,omitempty"`
	} `json:"tasks,omitempty"`

	// Time Time properties
	Time *struct {
		// Elapsed Total time elapsed
		Elapsed *int `json:"elapsed,omitempty"`

		// End Timestamp of when job ended
		End *int `json:"end,omitempty"`

		// Start Timestamp of when job started
		Start *int `json:"start,omitempty"`

		// Suspended Timestamp of when job last suspended
		Suspended *int `json:"suspended,omitempty"`

		// System System time values
		System *struct {
			// Microseconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"system,omitempty"`

		// Total System time values
		Total *struct {
			// Microseconds Total number of CPU-seconds used by the job, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"total,omitempty"`

		// User User land time values
		User *struct {
			// Microseconds Total number of CPU-seconds used by the job in user land, in microseconds
			Microseconds *int `json:"microseconds,omitempty"`

			// Seconds Total number of CPU-seconds used by the job in user land, in seconds
			Seconds *int `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`

	// Tres TRES usage
	Tres *struct {
		// Allocated TRES list of attributes
		Allocated *Dbv0037TresList `json:"allocated,omitempty"`

		// Consumed TRES requested for job
		Consumed *struct {
			// Average TRES list of attributes
			Average *Dbv0037TresList `json:"average,omitempty"`

			// Max TRES list of attributes
			Max *Dbv0037TresList `json:"max,omitempty"`

			// Min TRES list of attributes
			Min *Dbv0037TresList `json:"min,omitempty"`

			// Total TRES list of attributes
			Total *Dbv0037TresList `json:"total,omitempty"`
		} `json:"consumed,omitempty"`

		// Requested TRES requested for job
		Requested *struct {
			// Average TRES list of attributes
			Average *Dbv0037TresList `json:"average,omitempty"`

			// Max TRES list of attributes
			Max *Dbv0037TresList `json:"max,omitempty"`

			// Min TRES list of attributes
			Min *Dbv0037TresList `json:"min,omitempty"`

			// Total TRES list of attributes
			Total *Dbv0037TresList `json:"total,omitempty"`
		} `json:"requested,omitempty"`
	} `json:"tres,omitempty"`
}

// Dbv0037Qos QOS description
type Dbv0037Qos struct {
	// Description QOS description
	Description *string `json:"description,omitempty"`

	// Flags List of properties of QOS
	Flags *[]string `json:"flags,omitempty"`

	// Id Database id
	Id *string `json:"id,omitempty"`

	// Limits Assigned limits
	Limits *struct {
		// Max Limits on max settings
		Max *struct {
			// Accruing Limits on accruing priority
			Accruing *struct {
				// Per Max accuring priority per setting
				Per *struct {
					// Account Max accuring priority per account
					Account *int `json:"account,omitempty"`

					// User Max accuring priority per user
					User *int `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"accruing,omitempty"`

			// Jobs Limits on jobs settings
			Jobs *struct {
				// Per Limits on jobs per settings
				Per *struct {
					// Account Max jobs per account
					Account *int `json:"account,omitempty"`

					// User Max jobs per user
					User *int `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"jobs,omitempty"`

			// Tres Limits on TRES
			Tres *struct {
				// Minutes Max TRES minutes settings
				Minutes *struct {
					// Per Max TRES minutes per settings
					Per *struct {
						// Account TRES list of attributes
						Account *Dbv0037TresList `json:"account,omitempty"`

						// Job TRES list of attributes
						Job *Dbv0037TresList `json:"job,omitempty"`

						// User TRES list of attributes
						User *Dbv0037TresList `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"minutes,omitempty"`

				// Per Max TRES per settings
				Per *struct {
					// Account TRES list of attributes
					Account *Dbv0037TresList `json:"account,omitempty"`

					// Job TRES list of attributes
					Job *Dbv0037TresList `json:"job,omitempty"`

					// Node TRES list of attributes
					Node *Dbv0037TresList `json:"node,omitempty"`

					// User TRES list of attributes
					User *Dbv0037TresList `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"tres,omitempty"`

			// WallClock Limit on wallclock settings
			WallClock *struct {
				// Per Limit on wallclock per settings
				Per *struct {
					// Job Max wallclock per job
					Job *int `json:"job,omitempty"`

					// Qos Max wallclock per QOS
					Qos *int `json:"qos,omitempty"`
				} `json:"per,omitempty"`
			} `json:"wall_clock,omitempty"`
		} `json:"max,omitempty"`

		// Min Min limit settings
		Min *struct {
			// PriorityThreshold Min priority threshold
			PriorityThreshold *int `json:"priority_threshold,omitempty"`

			// Tres Min tres settings
			Tres *struct {
				// Per Min tres per settings
				Per *struct {
					// Job TRES list of attributes
					Job *Dbv0037TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"min,omitempty"`
	} `json:"limits,omitempty"`

	// Preempt Preemption settings
	Preempt *struct {
		// ExemptTime Grace period (s) before jobs can preempted
		ExemptTime *int `json:"exempt_time,omitempty"`

		// List List of preemptable QOS
		List *[]string `json:"list,omitempty"`

		// Mode List of preemption modes
		Mode *[]string `json:"mode,omitempty"`
	} `json:"preempt,omitempty"`

	// Priority QOS priority
	Priority *int `json:"priority,omitempty"`

	// UsageFactor Usage factor
	UsageFactor *float32 `json:"usage_factor,omitempty"`

	// UsageThreshold Usage threshold
	UsageThreshold *float32 `json:"usage_threshold,omitempty"`
}

// Dbv0037QosInfo defines model for dbv0.0.37_qos_info.
type Dbv0037QosInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`

	// Qos Array of QOS
	Qos *[]Dbv0037Qos `json:"qos,omitempty"`
}

// Dbv0037ResponseAccountDelete defines model for dbv0.0.37_response_account_delete.
type Dbv0037ResponseAccountDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseAssociationDelete defines model for dbv0.0.37_response_association_delete.
type Dbv0037ResponseAssociationDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseAssociations defines model for dbv0.0.37_response_associations.
type Dbv0037ResponseAssociations struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseClusterAdd defines model for dbv0.0.37_response_cluster_add.
type Dbv0037ResponseClusterAdd struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseClusterDelete defines model for dbv0.0.37_response_cluster_delete.
type Dbv0037ResponseClusterDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseQosDelete defines model for dbv0.0.37_response_qos_delete.
type Dbv0037ResponseQosDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseTres defines model for dbv0.0.37_response_tres.
type Dbv0037ResponseTres struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseUserDelete defines model for dbv0.0.37_response_user_delete.
type Dbv0037ResponseUserDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseUserUpdate defines model for dbv0.0.37_response_user_update.
type Dbv0037ResponseUserUpdate struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseWckeyAdd defines model for dbv0.0.37_response_wckey_add.
type Dbv0037ResponseWckeyAdd struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037ResponseWckeyDelete defines model for dbv0.0.37_response_wckey_delete.
type Dbv0037ResponseWckeyDelete struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`
}

// Dbv0037TresInfo defines model for dbv0.0.37_tres_info.
type Dbv0037TresInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`

	// Tres Array of tres
	Tres *[]Dbv0037TresList `json:"tres,omitempty"`
}

// Dbv0037TresList TRES list of attributes
type Dbv0037TresList = []struct {
	// Count count of TRES
	Count *int `json:"count,omitempty"`

	// Id database id
	Id *int `json:"id,omitempty"`

	// Name TRES name (optional)
	Name *string `json:"name,omitempty"`

	// Type TRES type
	Type *string `json:"type,omitempty"`
}

// Dbv0037User User description
type Dbv0037User struct {
	// AdministratorLevel Description of administrator level
	AdministratorLevel *string `json:"administrator_level,omitempty"`

	// Associations Assigned associations
	Associations *struct {
		Root *Dbv0037AssociationShortInfo `json:"root,omitempty"`
	} `json:"associations,omitempty"`

	// Coordinators List of assigned coordinators
	Coordinators *[]Dbv0037CoordinatorInfo `json:"coordinators,omitempty"`

	// Default Default settings
	Default *struct {
		// Account Default account name
		Account *string `json:"account,omitempty"`

		// Wckey Default wckey
		Wckey *string `json:"wckey,omitempty"`
	} `json:"default,omitempty"`

	// Name User name
	Name *string `json:"name,omitempty"`
}

// Dbv0037UserInfo defines model for dbv0.0.37_user_info.
type Dbv0037UserInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`

	// Users Array of users
	Users *[]Dbv0037User `json:"users,omitempty"`
}

// Dbv0037Wckey defines model for dbv0.0.37_wckey.
type Dbv0037Wckey struct {
	// Accounts List of assigned accounts
	Accounts *[]string `json:"accounts,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Flags List of properties of wckey
	Flags *[]string `json:"flags,omitempty"`

	// Id wckey database unique id
	Id *int `json:"id,omitempty"`

	// Name wckey name
	Name *string `json:"name,omitempty"`

	// User wckey user
	User *string `json:"user,omitempty"`
}

// Dbv0037WckeyInfo defines model for dbv0.0.37_wckey_info.
type Dbv0037WckeyInfo struct {
	// Errors Slurm errors
	Errors *[]Dbv0037Error `json:"errors,omitempty"`

	// Wckeys List of wckeys
	Wckeys *[]Dbv0037Wckey `json:"wckeys,omitempty"`
}

// JobProperties defines model for job_properties.
type JobProperties struct {
	// Account Charge resources used by this job to specified account.
	Account *string `json:"account,omitempty"`

	// AccountGatherFreqency Define the job accounting and profiling sampling intervals.
	AccountGatherFreqency *string `json:"account_gather_freqency,omitempty"`

	// Argv Arguments to the script.
	Argv *[]string `json:"argv,omitempty"`

	// Array Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
	Array *string `json:"array,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
	BeginTime *string `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specification.
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraints Specifies features that a federated cluster must have to have a sibling job submitted to it.
	ClusterConstraints *string `json:"cluster_constraints,omitempty"`

	// Comment An arbitrary comment.
	Comment *string `json:"comment,omitempty"`

	// Constraints node features required by job.
	Constraints *string `json:"constraints,omitempty"`

	// CoreSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	CoreSpecification *int `json:"core_specification,omitempty"`

	// CoresPerSocket Restrict node selection to nodes with at least the specified number of cores per socket.
	CoresPerSocket *int `json:"cores_per_socket,omitempty"`

	// CpuBinding Cpu binding
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingHint Cpu binding hint
	CpuBindingHint *string `json:"cpu_binding_hint,omitempty"`

	// CpuFrequency Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerGpu Number of CPUs requested per allocated GPU.
	CpusPerGpu *string `json:"cpus_per_gpu,omitempty"`

	// CpusPerTask Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
	CpusPerTask *int `json:"cpus_per_task,omitempty"`

	// CurrentWorkingDirectory Instruct Slurm to connect the batch script's standard output directly to the file name.
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])). (Unix timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Do not reboot nodes in order to satisfied this job's feature specification if the job has been eligible to run for less than this time period.
	DelayBoot *int `json:"delay_boot,omitempty"`

	// Dependency Defer the start of this job until the specified dependencies have been satisfied completed.
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Specify alternate distribution methods for remote processes.
	Distribution *string `json:"distribution,omitempty"`

	// Environment Dictionary of environment entries.
	Environment *map[string]interface{}  `json:"environment,omitempty"`
	Exclusive   *JobProperties_Exclusive `json:"exclusive,omitempty"`

	// GetUserEnvironment Load new login environment for user on job node.
	GetUserEnvironment *bool `json:"get_user_environment,omitempty"`

	// GpuBinding Requested binding of tasks to GPU.
	GpuBinding *string `json:"gpu_binding,omitempty"`

	// GpuFrequency Requested GPU frequency.
	GpuFrequency *string `json:"gpu_frequency,omitempty"`

	// Gpus GPUs per job.
	Gpus *string `json:"gpus,omitempty"`

	// GpusPerNode GPUs per node.
	GpusPerNode *string `json:"gpus_per_node,omitempty"`

	// GpusPerSocket GPUs per socket.
	GpusPerSocket *string `json:"gpus_per_socket,omitempty"`

	// GpusPerTask GPUs per task.
	GpusPerTask *string `json:"gpus_per_task,omitempty"`

	// Gres Specifies a comma delimited list of generic consumable resources.
	Gres *string `json:"gres,omitempty"`

	// GresFlags Specify generic resource task binding options.
	GresFlags *JobPropertiesGresFlags `json:"gres_flags,omitempty"`

	// Hold Specify the job is to be submitted in a held state (priority of zero).
	Hold *bool `json:"hold,omitempty"`

	// KillOnInvalidDependency If a job has an invalid dependency, then Slurm is to terminate it.
	KillOnInvalidDependency *bool `json:"kill_on_invalid_dependency,omitempty"`

	// Licenses Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
	Licenses *string `json:"licenses,omitempty"`

	// MailType Notify user by email when certain event types occur.
	MailType *string `json:"mail_type,omitempty"`

	// MailUser User to receive email notification of state changes as defined by mail_type.
	MailUser *string `json:"mail_user,omitempty"`

	// McsLabel This parameter is a group among the groups of the user.
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Bind tasks to memory.
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryPerCpu Minimum real memory per cpu (MB).
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// MemoryPerGpu Minimum memory required per allocated GPU.
	MemoryPerGpu *int `json:"memory_per_gpu,omitempty"`

	// MemoryPerNode Minimum real memory per node (MB).
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node.
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes If a range of node counts is given, prefer the smaller count.
	MinimumNodes *bool `json:"minimum_nodes,omitempty"`

	// Name Specify a name for the job allocation.
	Name *string `json:"name,omitempty"`

	// Nice Run the job with an adjusted scheduling priority within Slurm.
	Nice *string `json:"nice,omitempty"`

	// NoKill Do not automatically terminate a job if one of the nodes it has been allocated fails.
	NoKill *bool                `json:"no_kill,omitempty"`
	Nodes  *JobProperties_Nodes `json:"nodes,omitempty"`

	// OpenMode Open the output and error files using append or truncate mode as specified.
	OpenMode *JobPropertiesOpenMode `json:"open_mode,omitempty"`

	// Partition Request a specific partition for the resource allocation.
	Partition *string `json:"partition,omitempty"`

	// Priority Request a specific job priority.
	Priority *int `json:"priority,omitempty"`

	// Qos Request a quality of service for the job.
	Qos *string `json:"qos,omitempty"`

	// Requeue Specifies that the batch job should eligible to being requeue.
	Requeue *bool `json:"requeue,omitempty"`

	// Reservation Allocate resources for the job from the named reservation.
	Reservation *string `json:"reservation,omitempty"`

	// Signal When a job is within sig_time seconds of its end time, send it the signal sig_num.
	Signal *string `json:"signal,omitempty"`

	// SocketsPerNode Restrict node selection to nodes with at least the specified number of sockets.
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// SpreadJob Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
	SpreadJob *bool `json:"spread_job,omitempty"`

	// StandardError Instruct Slurm to connect the batch script's standard error directly to the file name.
	StandardError *string `json:"standard_error,omitempty"`

	// StandardIn Instruct Slurm to connect the batch script's standard input directly to the file name specified.
	StandardIn *string `json:"standard_in,omitempty"`

	// StandardOut Instruct Slurm to connect the batch script's standard output directly to the file name.
	StandardOut *string `json:"standard_out,omitempty"`

	// Tasks Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerCore Request the maximum ntasks be invoked on each core.
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// TasksPerNode Request the maximum ntasks be invoked on each node.
	TasksPerNode *int `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Request the maximum ntasks be invoked on each socket.
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// ThreadSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	ThreadSpecification *int `json:"thread_specification,omitempty"`

	// ThreadsPerCore Restrict node selection to nodes with at least the specified number of threads per core.
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// TimeLimit Step time limit.
	TimeLimit *int `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes.
	TimeMinimum *int `json:"time_minimum,omitempty"`

	// WaitAllNodes Do not begin execution until all nodes are ready for use.
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// Wckey Specify wckey to be used with job.
	Wckey *string `json:"wckey,omitempty"`
}

// JobPropertiesExclusive0 The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
type JobPropertiesExclusive0 string

// JobPropertiesExclusive1 Request exclusive use of nodes.
type JobPropertiesExclusive1 = bool

// JobProperties_Exclusive defines model for JobProperties.Exclusive.
type JobProperties_Exclusive struct {
	union json.RawMessage
}

// JobPropertiesGresFlags Specify generic resource task binding options.
type JobPropertiesGresFlags string

// JobPropertiesNodes0 Request that a minimum of minnodes nodes be allocated to this job.
type JobPropertiesNodes0 = int

// JobPropertiesNodes1 Request that a minimum of minnodes nodes and a maximum node count.
type JobPropertiesNodes1 = []int

// JobProperties_Nodes defines model for JobProperties.Nodes.
type JobProperties_Nodes struct {
	union json.RawMessage
}

// JobPropertiesOpenMode Open the output and error files using append or truncate mode as specified.
type JobPropertiesOpenMode string

// Signal defines model for signal.
type Signal struct {
	union json.RawMessage
}

// Signal0 POSIX signal number
type Signal0 = int32

// Signal1 POSIX signal name
type Signal1 string

// V0036Diag defines model for v0.0.36_diag.
type V0036Diag struct {
	// Errors slurm errors
	Errors *[]V0036Error `json:"errors,omitempty"`

	// Statistics Slurm statistics
	Statistics *struct {
		// AgentCount Agent count
		AgentCount *int `json:"agent_count,omitempty"`

		// AgentQueueSize Agent queue size
		AgentQueueSize *int `json:"agent_queue_size,omitempty"`

		// AgentThreadCount Agent thread count
		AgentThreadCount *int `json:"agent_thread_count,omitempty"`

		// BfActive Backfill Schedule currently active
		BfActive *bool `json:"bf_active,omitempty"`

		// BfBackfilledHetJobs Total backfilled heterogeneous job components
		BfBackfilledHetJobs *int `json:"bf_backfilled_het_jobs,omitempty"`

		// BfBackfilledJobs Total backfilled jobs (since last slurm start)
		BfBackfilledJobs *int `json:"bf_backfilled_jobs,omitempty"`

		// BfCycleCounter Backfill Schedule Total cycles
		BfCycleCounter *int `json:"bf_cycle_counter,omitempty"`

		// BfCycleLast Backfill Schedule Last cycle time
		BfCycleLast *int `json:"bf_cycle_last,omitempty"`

		// BfCycleMax Backfill Schedule Max cycle time
		BfCycleMax *int `json:"bf_cycle_max,omitempty"`

		// BfCycleMean Backfill Schedule Mean cycle
		BfCycleMean *int `json:"bf_cycle_mean,omitempty"`

		// BfDepthMean Backfill Schedule Depth Mean
		BfDepthMean *int `json:"bf_depth_mean,omitempty"`

		// BfDepthMeanTry Backfill Schedule Depth Mean (try sched)
		BfDepthMeanTry *int `json:"bf_depth_mean_try,omitempty"`

		// BfLastBackfilledJobs Total backfilled jobs (since last stats cycle start)
		BfLastBackfilledJobs *int `json:"bf_last_backfilled_jobs,omitempty"`

		// BfLastDepth Backfill Schedule Last depth cycle
		BfLastDepth *int `json:"bf_last_depth,omitempty"`

		// BfLastDepthTry Backfill Schedule Mean cycle (try sched)
		BfLastDepthTry *int `json:"bf_last_depth_try,omitempty"`

		// BfQueueLen Backfill Schedule Last queue length
		BfQueueLen *int `json:"bf_queue_len,omitempty"`

		// BfQueueLenMean Backfill Schedule Mean queue length
		BfQueueLenMean *int `json:"bf_queue_len_mean,omitempty"`

		// BfWhenLastCycle Last cycle timestamp
		BfWhenLastCycle *int `json:"bf_when_last_cycle,omitempty"`

		// DbdAgentQueueSize DBD Agent queue size
		DbdAgentQueueSize *int `json:"dbd_agent_queue_size,omitempty"`

		// GettimeofdayLatency Latency for 1000 calls to gettimeofday()
		GettimeofdayLatency *int `json:"gettimeofday_latency,omitempty"`

		// JobStatesTs Job states timestamp
		JobStatesTs *int `json:"job_states_ts,omitempty"`

		// JobsCanceled Job cancelled
		JobsCanceled *int `json:"jobs_canceled,omitempty"`

		// JobsCompleted Job completed
		JobsCompleted *int `json:"jobs_completed,omitempty"`

		// JobsFailed Job failed
		JobsFailed *int `json:"jobs_failed,omitempty"`

		// JobsPending Job pending
		JobsPending *int `json:"jobs_pending,omitempty"`

		// JobsRunning Job running
		JobsRunning *int `json:"jobs_running,omitempty"`

		// JobsStarted Job started
		JobsStarted *int `json:"jobs_started,omitempty"`

		// JobsSubmitted Job submitted
		JobsSubmitted *int `json:"jobs_submitted,omitempty"`

		// PartsPacked partition records packed
		PartsPacked *int `json:"parts_packed,omitempty"`

		// ReqTime generation time
		ReqTime *int `json:"req_time,omitempty"`

		// ReqTimeStart data since
		ReqTimeStart *int `json:"req_time_start,omitempty"`

		// ScheduleCycleLast Main Schedule last cycle
		ScheduleCycleLast *int `json:"schedule_cycle_last,omitempty"`

		// ScheduleCycleMax Main Schedule max cycle
		ScheduleCycleMax *int `json:"schedule_cycle_max,omitempty"`

		// ScheduleCycleMean Average time for Schedule Max cycle
		ScheduleCycleMean *int `json:"schedule_cycle_mean,omitempty"`

		// ScheduleCycleMeanDepth Average depth for Schedule Max cycle
		ScheduleCycleMeanDepth *int `json:"schedule_cycle_mean_depth,omitempty"`

		// ScheduleCyclePerMinute Main Schedule Cycles per minute
		ScheduleCyclePerMinute *int `json:"schedule_cycle_per_minute,omitempty"`

		// ScheduleCycleTotal Main Schedule cycle iterations
		ScheduleCycleTotal *int `json:"schedule_cycle_total,omitempty"`

		// ScheduleQueueLength Main Schedule Last queue length
		ScheduleQueueLength *int `json:"schedule_queue_length,omitempty"`

		// ServerThreadCount Server thread count
		ServerThreadCount *int `json:"server_thread_count,omitempty"`
	} `json:"statistics,omitempty"`
}

// V0036Error defines model for v0.0.36_error.
type V0036Error struct {
	// Errno error number
	Errno *int `json:"errno,omitempty"`

	// Error error message
	Error *string `json:"error,omitempty"`
}

// V0036JobProperties defines model for v0.0.36_job_properties.
type V0036JobProperties struct {
	// Account Charge resources used by this job to specified account.
	Account *string `json:"account,omitempty"`

	// AccountGatherFreqency Define the job accounting and profiling sampling intervals.
	AccountGatherFreqency *string `json:"account_gather_freqency,omitempty"`

	// Argv Arguments to the script.
	Argv *[]string `json:"argv,omitempty"`

	// Array Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
	Array *string `json:"array,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
	BeginTime *string `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specification.
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraints Specifies features that a federated cluster must have to have a sibling job submitted to it.
	ClusterConstraints *string `json:"cluster_constraints,omitempty"`

	// Comment An arbitrary comment.
	Comment *string `json:"comment,omitempty"`

	// Constraints node features required by job.
	Constraints *string `json:"constraints,omitempty"`

	// CoreSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	CoreSpecification *int `json:"core_specification,omitempty"`

	// CoresPerSocket Restrict node selection to nodes with at least the specified number of cores per socket.
	CoresPerSocket *int `json:"cores_per_socket,omitempty"`

	// CpuBinding Cpu binding
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingHint Cpu binding hint
	CpuBindingHint *string `json:"cpu_binding_hint,omitempty"`

	// CpuFrequency Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerGpu Number of CPUs requested per allocated GPU.
	CpusPerGpu *string `json:"cpus_per_gpu,omitempty"`

	// CpusPerTask Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
	CpusPerTask *int `json:"cpus_per_task,omitempty"`

	// CurrentWorkingDirectory Instruct Slurm to connect the batch script's standard output directly to the file name.
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])). (Unix timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Do not reboot nodes in order to satisfied this job's feature specification if the job has been eligible to run for less than this time period.
	DelayBoot *int `json:"delay_boot,omitempty"`

	// Dependency Defer the start of this job until the specified dependencies have been satisfied completed.
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Specify alternate distribution methods for remote processes.
	Distribution *string `json:"distribution,omitempty"`

	// Environment Dictionary of environment entries.
	Environment map[string]interface{} `json:"environment"`

	// Exclusive The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
	Exclusive *V0036JobPropertiesExclusive `json:"exclusive,omitempty"`

	// GetUserEnvironment Load new login environment for user on job node.
	GetUserEnvironment *bool `json:"get_user_environment,omitempty"`

	// GpuBinding Requested binding of tasks to GPU.
	GpuBinding *string `json:"gpu_binding,omitempty"`

	// GpuFrequency Requested GPU frequency.
	GpuFrequency *string `json:"gpu_frequency,omitempty"`

	// Gpus GPUs per job.
	Gpus *string `json:"gpus,omitempty"`

	// GpusPerNode GPUs per node.
	GpusPerNode *string `json:"gpus_per_node,omitempty"`

	// GpusPerSocket GPUs per socket.
	GpusPerSocket *string `json:"gpus_per_socket,omitempty"`

	// GpusPerTask GPUs per task.
	GpusPerTask *string `json:"gpus_per_task,omitempty"`

	// Gres Specifies a comma delimited list of generic consumable resources.
	Gres *string `json:"gres,omitempty"`

	// GresFlags Specify generic resource task binding options.
	GresFlags *V0036JobPropertiesGresFlags `json:"gres_flags,omitempty"`

	// Hold Specify the job is to be submitted in a held state (priority of zero).
	Hold *bool `json:"hold,omitempty"`

	// KillOnInvalidDependency If a job has an invalid dependency, then Slurm is to terminate it.
	KillOnInvalidDependency *bool `json:"kill_on_invalid_dependency,omitempty"`

	// Licenses Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
	Licenses *string `json:"licenses,omitempty"`

	// MailType Notify user by email when certain event types occur.
	MailType *string `json:"mail_type,omitempty"`

	// MailUser User to receive email notification of state changes as defined by mail_type.
	MailUser *string `json:"mail_user,omitempty"`

	// McsLabel This parameter is a group among the groups of the user.
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Bind tasks to memory.
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryPerCpu Minimum real memory per cpu (MB).
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// MemoryPerGpu Minimum memory required per allocated GPU.
	MemoryPerGpu *int `json:"memory_per_gpu,omitempty"`

	// MemoryPerNode Minimum real memory per node (MB).
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node.
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes If a range of node counts is given, prefer the smaller count.
	MinimumNodes *bool `json:"minimum_nodes,omitempty"`

	// Name Specify a name for the job allocation.
	Name *string `json:"name,omitempty"`

	// Nice Run the job with an adjusted scheduling priority within Slurm.
	Nice *string `json:"nice,omitempty"`

	// NoKill Do not automatically terminate a job if one of the nodes it has been allocated fails.
	NoKill *bool `json:"no_kill,omitempty"`

	// Nodes Request that a minimum of minnodes nodes and a maximum node count.
	Nodes *[]int `json:"nodes,omitempty"`

	// OpenMode Open the output and error files using append or truncate mode as specified.
	OpenMode *V0036JobPropertiesOpenMode `json:"open_mode,omitempty"`

	// Partition Request a specific partition for the resource allocation.
	Partition *string `json:"partition,omitempty"`

	// Priority Request a specific job priority.
	Priority *int `json:"priority,omitempty"`

	// Qos Request a quality of service for the job.
	Qos *string `json:"qos,omitempty"`

	// Requeue Specifies that the batch job should eligible to being requeue.
	Requeue *bool `json:"requeue,omitempty"`

	// Reservation Allocate resources for the job from the named reservation.
	Reservation *string `json:"reservation,omitempty"`

	// Signal When a job is within sig_time seconds of its end time, send it the signal sig_num.
	Signal *string `json:"signal,omitempty"`

	// SocketsPerNode Restrict node selection to nodes with at least the specified number of sockets.
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// SpreadJob Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
	SpreadJob *bool `json:"spread_job,omitempty"`

	// StandardError Instruct Slurm to connect the batch script's standard error directly to the file name.
	StandardError *string `json:"standard_error,omitempty"`

	// StandardIn Instruct Slurm to connect the batch script's standard input directly to the file name specified.
	StandardIn *string `json:"standard_in,omitempty"`

	// StandardOut Instruct Slurm to connect the batch script's standard output directly to the file name.
	StandardOut *string `json:"standard_out,omitempty"`

	// Tasks Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerCore Request the maximum ntasks be invoked on each core.
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// TasksPerNode Request the maximum ntasks be invoked on each node.
	TasksPerNode *int `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Request the maximum ntasks be invoked on each socket.
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// ThreadSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	ThreadSpecification *int `json:"thread_specification,omitempty"`

	// ThreadsPerCore Restrict node selection to nodes with at least the specified number of threads per core.
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// TimeLimit Step time limit.
	TimeLimit *int `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes.
	TimeMinimum *int `json:"time_minimum,omitempty"`

	// WaitAllNodes Do not begin execution until all nodes are ready for use.
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// Wckey Specify wckey to be used with job.
	Wckey *string `json:"wckey,omitempty"`
}

// V0036JobPropertiesExclusive The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
type V0036JobPropertiesExclusive string

// V0036JobPropertiesGresFlags Specify generic resource task binding options.
type V0036JobPropertiesGresFlags string

// V0036JobPropertiesOpenMode Open the output and error files using append or truncate mode as specified.
type V0036JobPropertiesOpenMode string

// V0036JobResources defines model for v0.0.36_job_resources.
type V0036JobResources struct {
	// AllocatedCpus number of assigned job cpus
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// AllocatedHosts number of assigned job hosts
	AllocatedHosts *int `json:"allocated_hosts,omitempty"`

	// AllocatedNodes node allocations (map with node indices as keys)
	AllocatedNodes *map[string]V0036NodeAllocation `json:"allocated_nodes,omitempty"`

	// Nodes list of assigned job nodes
	Nodes *string `json:"nodes,omitempty"`
}

// V0036JobResponseProperties defines model for v0.0.36_job_response_properties.
type V0036JobResponseProperties struct {
	// Account Charge resources used by this job to specified account
	Account *string `json:"account,omitempty"`

	// AccrueTime time job is eligible for running (Unix timestamp)
	AccrueTime *int64 `json:"accrue_time,omitempty"`

	// AdminComment administrator's arbitrary comment
	AdminComment *string `json:"admin_comment,omitempty"`

	// ArrayJobId job_id of a job array or 0 if N/A
	ArrayJobId *int `json:"array_job_id,omitempty"`

	// ArrayMaxTasks Maximum number of running array tasks
	ArrayMaxTasks *int `json:"array_max_tasks,omitempty"`

	// ArrayTaskId task_id of a job array
	ArrayTaskId *int `json:"array_task_id,omitempty"`

	// ArrayTaskString string expression of task IDs in this record
	ArrayTaskString *string `json:"array_task_string,omitempty"`

	// AssociationId association id for job
	AssociationId *int `json:"association_id,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BatchFlag if batch: queued job with script
	BatchFlag *bool `json:"batch_flag,omitempty"`

	// BatchHost name of host running batch script
	BatchHost *string `json:"batch_host,omitempty"`

	// BillableTres billable TRES
	BillableTres *float64 `json:"billable_tres,omitempty"`

	// BurstBuffer burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// BurstBufferState burst buffer state info
	BurstBufferState *string `json:"burst_buffer_state,omitempty"`

	// Cluster name of cluster that the job is on
	Cluster *string `json:"cluster,omitempty"`

	// ClusterFeatures comma separated list of required cluster features
	ClusterFeatures *string `json:"cluster_features,omitempty"`

	// Command command to be executed
	Command *string `json:"command,omitempty"`

	// Comment arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Contiguous job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpec specialized core count
	CoreSpec *string `json:"core_spec,omitempty"`

	// CoresPerSocket cores per socket required by job
	CoresPerSocket *string `json:"cores_per_socket,omitempty"`

	// CpuFrequencyGovernor cpu frequency governor
	CpuFrequencyGovernor *string `json:"cpu_frequency_governor,omitempty"`

	// CpuFrequencyMaximum Maximum cpu frequency
	CpuFrequencyMaximum *string `json:"cpu_frequency_maximum,omitempty"`

	// CpuFrequencyMinimum Minimum cpu frequency
	CpuFrequencyMinimum *string `json:"cpu_frequency_minimum,omitempty"`

	// Cpus minimum number of cpus required by job
	Cpus *int `json:"cpus,omitempty"`

	// CpusPerTask number of processors required for each task
	CpusPerTask *string `json:"cpus_per_task,omitempty"`

	// CpusPerTres semicolon delimited list of TRES=# values
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// CurrentWorkingDirectory pathname of working directory
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline job start deadline  (Unix timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot command to be executed (Unix timestamp)
	DelayBoot *int64 `json:"delay_boot,omitempty"`

	// Dependency synchronize job execution with other jobs
	Dependency *string `json:"dependency,omitempty"`

	// DerivedExitCode highest exit code of all job steps
	DerivedExitCode *int `json:"derived_exit_code,omitempty"`

	// EligibleTime time job is eligible for running (Unix timestamp)
	EligibleTime *int64 `json:"eligible_time,omitempty"`

	// EndTime time of termination, actual or expected (Unix timestamp)
	EndTime *int64 `json:"end_time,omitempty"`

	// ExcludedNodes comma separated list of excluded nodes
	ExcludedNodes *string `json:"excluded_nodes,omitempty"`

	// ExitCode exit code for job
	ExitCode *int `json:"exit_code,omitempty"`

	// Features comma separated list of required features
	Features *string `json:"features,omitempty"`

	// FederationOrigin Origin cluster's name
	FederationOrigin *string `json:"federation_origin,omitempty"`

	// FederationSiblingsActive string of active sibling names
	FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

	// FederationSiblingsViable string of viable sibling names
	FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

	// Flags Job flags
	Flags *[]string `json:"flags,omitempty"`

	// GresDetail Job flags
	GresDetail *[]string `json:"gres_detail,omitempty"`

	// GroupId group job submitted as
	GroupId *int `json:"group_id,omitempty"`

	// HetJobId job ID of hetjob leader
	HetJobId *int `json:"het_job_id,omitempty"`

	// HetJobIdSet job IDs for all components
	HetJobIdSet *string `json:"het_job_id_set,omitempty"`

	// HetJobOffset HetJob component offset from leader
	HetJobOffset *int `json:"het_job_offset,omitempty"`

	// JobId job ID
	JobId *int `json:"job_id,omitempty"`

	// JobState state of the job
	JobState *string `json:"job_state,omitempty"`

	// LastSchedEvaluation last time job was evaluated for scheduling (Unix timestamp)
	LastSchedEvaluation *int64 `json:"last_sched_evaluation,omitempty"`

	// Licenses licenses required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MaxCpus maximum number of cpus usable by job
	MaxCpus *int `json:"max_cpus,omitempty"`

	// MaxNodes maximum number of nodes usable by job
	MaxNodes *int `json:"max_nodes,omitempty"`

	// McsLabel mcs_label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryPerCpu minimum real memory per cpu
	MemoryPerCpu *string `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode minimum real memory per node
	MemoryPerNode *string `json:"memory_per_node,omitempty"`

	// MemoryPerTres semicolon delimited list of TRES=# values
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumCpusPerNode minimum # CPUs per node
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumTmpDiskPerNode minimum tmp disk per node
	MinimumTmpDiskPerNode *int `json:"minimum_tmp_disk_per_node,omitempty"`

	// Name name of the job
	Name *string `json:"name,omitempty"`

	// Nice requested priority change
	Nice *string `json:"nice,omitempty"`

	// NodeCount minimum number of nodes required by job
	NodeCount *int `json:"node_count,omitempty"`

	// Nodes list of nodes allocated to job
	Nodes *string `json:"nodes,omitempty"`

	// Partition name of assigned partition
	Partition *string `json:"partition,omitempty"`

	// PreSusTime time job ran prior to last suspend (Unix timestamp)
	PreSusTime *int64 `json:"pre_sus_time,omitempty"`

	// PreemptTime preemption signal time (Unix timestamp)
	PreemptTime *int64 `json:"preempt_time,omitempty"`

	// Priority relative priority of the job
	Priority *int `json:"priority,omitempty"`

	// Profile Job profiling requested
	Profile *[]string `json:"profile,omitempty"`

	// Qos Quality of Service
	Qos *string `json:"qos,omitempty"`

	// Reboot node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue enable or disable job requeue option
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes comma separated list of required nodes
	RequiredNodes *string `json:"required_nodes,omitempty"`

	// ResizeTime time of latest size change (Unix timestamp)
	ResizeTime *int64 `json:"resize_time,omitempty"`

	// RestartCnt count of job restarts
	RestartCnt *int `json:"restart_cnt,omitempty"`

	// ResvName reservation name
	ResvName *string `json:"resv_name,omitempty"`

	// Shared type and if job can share nodes with other jobs
	Shared *int `json:"shared,omitempty"`

	// ShowFlags details requested
	ShowFlags *[]string `json:"show_flags,omitempty"`

	// SocketsPerBoard sockets per board required by job
	SocketsPerBoard *int `json:"sockets_per_board,omitempty"`

	// SocketsPerNode sockets per node required by job
	SocketsPerNode *string `json:"sockets_per_node,omitempty"`

	// StandardError pathname of job's stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput pathname of job's stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput pathname of job's stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// StartTime time execution begins, actual or expected (Unix timestamp)
	StartTime *int64 `json:"start_time,omitempty"`

	// StateDescription optional details for state_reason
	StateDescription *string `json:"state_description,omitempty"`

	// StateReason reason job still pending or failed
	StateReason *string `json:"state_reason,omitempty"`

	// SubmitTime time of job submission (Unix timestamp)
	SubmitTime *int64 `json:"submit_time,omitempty"`

	// SuspendTime time job last suspended or resumed (Unix timestamp)
	SuspendTime *int64 `json:"suspend_time,omitempty"`

	// SystemComment slurmctld's arbitrary comment
	SystemComment *string `json:"system_comment,omitempty"`

	// Tasks requested task count
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerBoard number of tasks to invoke on each board
	TasksPerBoard *int `json:"tasks_per_board,omitempty"`

	// TasksPerCore number of tasks to invoke on each core
	TasksPerCore *string `json:"tasks_per_core,omitempty"`

	// TasksPerSocket number of tasks to invoke on each socket
	TasksPerSocket *string `json:"tasks_per_socket,omitempty"`

	// ThreadSpec specialized thread count
	ThreadSpec *string `json:"thread_spec,omitempty"`

	// ThreadsPerCore threads per core required by job
	ThreadsPerCore *string `json:"threads_per_core,omitempty"`

	// TimeLimit maximum run time in minutes (Unix timestamp)
	TimeLimit *int64 `json:"time_limit,omitempty"`

	// TimeMinimum minimum run time in minutes (Unix timestamp)
	TimeMinimum *int64 `json:"time_minimum,omitempty"`

	// TresAllocStr tres used in the job
	TresAllocStr *string `json:"tres_alloc_str,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob semicolon delimited list of TRES=# values
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode semicolon delimited list of TRES=# values
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket semicolon delimited list of TRES=# values
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask semicolon delimited list of TRES=# values
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// TresReqStr tres reqeusted in the job
	TresReqStr *string `json:"tres_req_str,omitempty"`

	// UserId user id the job runs as
	UserId *int `json:"user_id,omitempty"`

	// UserName user the job runs as
	UserName *string `json:"user_name,omitempty"`

	// Wckey wckey for job
	Wckey *string `json:"wckey,omitempty"`
}

// V0036JobSubmission defines model for v0.0.36_job_submission.
type V0036JobSubmission struct {
	Job *V0036JobProperties `json:"job,omitempty"`

	// Jobs Properties of an HetJob
	Jobs *[]V0036JobProperties `json:"jobs,omitempty"`

	// Script Executable script (full contents) to run in batch step
	Script string `json:"script"`
}

// V0036JobSubmissionResponse defines model for v0.0.36_job_submission_response.
type V0036JobSubmissionResponse struct {
	// Errors slurm errors
	Errors *[]V0036Error `json:"errors,omitempty"`

	// JobId new job ID
	JobId *int `json:"job_id,omitempty"`

	// JobSubmitUserMsg Message to user from job_submit plugin
	JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

	// StepId new job step ID
	StepId *string `json:"step_id,omitempty"`
}

// V0036JobsResponse defines model for v0.0.36_jobs_response.
type V0036JobsResponse struct {
	// Errors slurm errors
	Errors *[]V0036Error `json:"errors,omitempty"`

	// Jobs job descriptions
	Jobs *[]V0036JobResponseProperties `json:"jobs,omitempty"`
}

// V0036Node defines model for v0.0.36_node.
type V0036Node struct {
	// ActiveFeatures list of a node's available features
	ActiveFeatures *string `json:"active_features,omitempty"`

	// Address state after reboot
	Address *string `json:"address,omitempty"`

	// Architecture computer architecture
	Architecture *string `json:"architecture,omitempty"`

	// Boards total number of boards per node
	Boards *int `json:"boards,omitempty"`

	// BootTime timestamp of node boot
	BootTime *int64 `json:"boot_time,omitempty"`

	// BurstbufferNetworkAddress BcastAddr
	BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Cores number of cores per socket
	Cores *int `json:"cores,omitempty"`

	// CpuBinding Default task binding
	CpuBinding *int `json:"cpu_binding,omitempty"`

	// CpuLoad CPU load * 100
	CpuLoad *int64 `json:"cpu_load,omitempty"`

	// Cpus configured count of cpus running on the node
	Cpus     *int    `json:"cpus,omitempty"`
	Features *string `json:"features,omitempty"`

	// FreeMemory free memory in MiB
	FreeMemory *int `json:"free_memory,omitempty"`

	// Gres list of a node's generic resources
	Gres *string `json:"gres,omitempty"`

	// GresDrained list of drained GRES
	GresDrained *string `json:"gres_drained,omitempty"`

	// GresUsed list of GRES in current use
	GresUsed *string `json:"gres_used,omitempty"`

	// Hostname node's hostname
	Hostname *string `json:"hostname,omitempty"`

	// McsLabel mcs label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// Name node name to slurm
	Name                 *string `json:"name,omitempty"`
	NextStateAfterReboot *string `json:"next_state_after_reboot,omitempty"`

	// OperatingSystem operating system
	OperatingSystem *string `json:"operating_system,omitempty"`

	// Owner User allowed to use this node
	Owner *string `json:"owner,omitempty"`

	// Port TCP port number of the slurmd
	Port *int `json:"port,omitempty"`

	// RealMemory configured MB of real memory on the node
	RealMemory *int `json:"real_memory,omitempty"`

	// Reason reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonChangedAt Time stamp when reason was set
	ReasonChangedAt *int `json:"reason_changed_at,omitempty"`

	// ReasonSetByUser User that set the reason
	ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

	// SlurmdStartTime timestamp of slurmd startup
	SlurmdStartTime *int64 `json:"slurmd_start_time,omitempty"`

	// SlurmdVersion Slurmd version
	SlurmdVersion *string `json:"slurmd_version,omitempty"`

	// Sockets total number of sockets per node
	Sockets *int `json:"sockets,omitempty"`

	// State current node state
	State *string `json:"state,omitempty"`

	// TemporaryDisk configured MB of total disk in TMP_FS
	TemporaryDisk *int `json:"temporary_disk,omitempty"`

	// Threads number of threads per core
	Threads *int `json:"threads,omitempty"`

	// Tres TRES on node
	Tres *string `json:"tres,omitempty"`

	// Weight arbitrary priority of node for scheduling
	Weight *int `json:"weight,omitempty"`
}

// V0036NodeAllocation defines model for v0.0.36_node_allocation.
type V0036NodeAllocation struct {
	// Cores assignment status of each core by core id
	Cores *map[string]interface{} `json:"cores,omitempty"`

	// Cpus amount of assigned job CPUs
	Cpus *map[string]interface{} `json:"cpus,omitempty"`

	// Memory amount of assigned job memory
	Memory *int `json:"memory,omitempty"`

	// Sockets assignment status of each socket by socket id
	Sockets *map[string]interface{} `json:"sockets,omitempty"`
}

// V0036NodesResponse defines model for v0.0.36_nodes_response.
type V0036NodesResponse struct {
	// Errors slurm errors
	Errors *[]V0036Error `json:"errors,omitempty"`

	// Nodes nodes info
	Nodes *[]V0036Node `json:"nodes,omitempty"`
}

// V0036Partition defines model for v0.0.36_partition.
type V0036Partition struct {
	// AllowedAccounts comma delimited list of accounts
	AllowedAccounts *string `json:"allowed_accounts,omitempty"`

	// AllowedAllocationNodes list names of allowed allocating nodes
	AllowedAllocationNodes *string `json:"allowed_allocation_nodes,omitempty"`

	// AllowedGroups comma delimited list of groups
	AllowedGroups *string `json:"allowed_groups,omitempty"`

	// AllowedQos comma delimited list of qos
	AllowedQos *string `json:"allowed_qos,omitempty"`

	// Alternative name of alternate partition
	Alternative *string `json:"alternative,omitempty"`

	// BillingWeights TRES billing weights
	BillingWeights *string `json:"billing_weights,omitempty"`

	// DefaultMemoryPerCpu default MB memory per allocated CPU
	DefaultMemoryPerCpu *int64 `json:"default_memory_per_cpu,omitempty"`

	// DefaultTimeLimit default time limit (minutes)
	DefaultTimeLimit *int64 `json:"default_time_limit,omitempty"`

	// DeniedAccounts comma delimited list of denied accounts
	DeniedAccounts *string `json:"denied_accounts,omitempty"`

	// DeniedQos comma delimited list of denied qos
	DeniedQos *string `json:"denied_qos,omitempty"`

	// Flags partition options
	Flags *[]string `json:"flags,omitempty"`

	// MaxTimeLimit Max time limit per job
	MaxTimeLimit *int64 `json:"max_time_limit,omitempty"`

	// MaximumCpusPerNode maximum allocated CPUs per node
	MaximumCpusPerNode *int `json:"maximum_cpus_per_node,omitempty"`

	// MaximumMemoryPerNode maximum memory per allocated CPU (MiB)
	MaximumMemoryPerNode *int64 `json:"maximum_memory_per_node,omitempty"`

	// MaximumNodesPerJob Max nodes per job
	MaximumNodesPerJob *int `json:"maximum_nodes_per_job,omitempty"`

	// MinNodesPerJob Min number of nodes per job
	MinNodesPerJob *int `json:"min_nodes_per_job,omitempty"`

	// Name Partition name
	Name *string `json:"name,omitempty"`

	// Nodes list names of nodes in partition
	Nodes *string `json:"nodes,omitempty"`

	// NodesOnline Nodes online (ready for jobs)
	NodesOnline *int `json:"nodes_online,omitempty"`

	// OverTimeLimit job's time limit can be exceeded by this number of minutes before cancellation
	OverTimeLimit *int `json:"over_time_limit,omitempty"`

	// PreemptionGraceTime preemption grace time (seconds)
	PreemptionGraceTime *int64 `json:"preemption_grace_time,omitempty"`

	// PreemptionMode preemption type
	PreemptionMode *string `json:"preemption_mode,omitempty"`

	// PriorityJobFactor job priority weight factor
	PriorityJobFactor *int `json:"priority_job_factor,omitempty"`

	// PriorityTier tier for scheduling and preemption
	PriorityTier *int `json:"priority_tier,omitempty"`

	// Qos partition QOS name
	Qos *string `json:"qos,omitempty"`

	// TotalCpus Total cpus in partition
	TotalCpus *int `json:"total_cpus,omitempty"`

	// TotalNodes Total number of nodes in partition
	TotalNodes *int `json:"total_nodes,omitempty"`

	// Tres configured TRES in partition
	Tres *string `json:"tres,omitempty"`
}

// V0036PartitionsResponse defines model for v0.0.36_partitions_response.
type V0036PartitionsResponse struct {
	// Errors slurm errors
	Errors *[]V0036Error `json:"errors,omitempty"`

	// Partitions partition info
	Partitions *[]V0036Partition `json:"partitions,omitempty"`
}

// V0036Ping defines model for v0.0.36_ping.
type V0036Ping struct {
	// Hostname slurm controller hostname
	Hostname *string `json:"hostname,omitempty"`

	// Mode slurm controller mode
	Mode *string `json:"mode,omitempty"`

	// Ping slurm controller host up
	Ping *V0036PingPing `json:"ping,omitempty"`

	// Status slurm controller status
	Status *int `json:"status,omitempty"`
}

// V0036PingPing slurm controller host up
type V0036PingPing string

// V0036Pings defines model for v0.0.36_pings.
type V0036Pings struct {
	// Errors slurm errors
	Errors *[]V0036Error `json:"errors,omitempty"`

	// Pings slurm controller pings
	Pings *[]V0036Ping `json:"pings,omitempty"`
}

// V0036Signal POSIX signal name
type V0036Signal string

// V0037Diag defines model for v0.0.37_diag.
type V0037Diag struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// Statistics Slurm statistics
	Statistics *struct {
		// AgentCount Agent count
		AgentCount *int `json:"agent_count,omitempty"`

		// AgentQueueSize Agent queue size
		AgentQueueSize *int `json:"agent_queue_size,omitempty"`

		// AgentThreadCount Agent thread count
		AgentThreadCount *int `json:"agent_thread_count,omitempty"`

		// BfActive Backfill Schedule currently active
		BfActive *bool `json:"bf_active,omitempty"`

		// BfBackfilledHetJobs Total backfilled heterogeneous job components
		BfBackfilledHetJobs *int `json:"bf_backfilled_het_jobs,omitempty"`

		// BfBackfilledJobs Total backfilled jobs (since last slurm start)
		BfBackfilledJobs *int `json:"bf_backfilled_jobs,omitempty"`

		// BfCycleCounter Backfill Schedule Total cycles
		BfCycleCounter *int `json:"bf_cycle_counter,omitempty"`

		// BfCycleLast Backfill Schedule Last cycle time
		BfCycleLast *int `json:"bf_cycle_last,omitempty"`

		// BfCycleMax Backfill Schedule Max cycle time
		BfCycleMax *int `json:"bf_cycle_max,omitempty"`

		// BfCycleMean Backfill Schedule Mean cycle
		BfCycleMean *int `json:"bf_cycle_mean,omitempty"`

		// BfDepthMean Backfill Schedule Depth Mean
		BfDepthMean *int `json:"bf_depth_mean,omitempty"`

		// BfDepthMeanTry Backfill Schedule Depth Mean (try sched)
		BfDepthMeanTry *int `json:"bf_depth_mean_try,omitempty"`

		// BfLastBackfilledJobs Total backfilled jobs (since last stats cycle start)
		BfLastBackfilledJobs *int `json:"bf_last_backfilled_jobs,omitempty"`

		// BfLastDepth Backfill Schedule Last depth cycle
		BfLastDepth *int `json:"bf_last_depth,omitempty"`

		// BfLastDepthTry Backfill Schedule Mean cycle (try sched)
		BfLastDepthTry *int `json:"bf_last_depth_try,omitempty"`

		// BfQueueLen Backfill Schedule Last queue length
		BfQueueLen *int `json:"bf_queue_len,omitempty"`

		// BfQueueLenMean Backfill Schedule Mean queue length
		BfQueueLenMean *int `json:"bf_queue_len_mean,omitempty"`

		// BfWhenLastCycle Last cycle timestamp
		BfWhenLastCycle *int `json:"bf_when_last_cycle,omitempty"`

		// DbdAgentQueueSize DBD Agent queue size
		DbdAgentQueueSize *int `json:"dbd_agent_queue_size,omitempty"`

		// GettimeofdayLatency Latency for 1000 calls to gettimeofday()
		GettimeofdayLatency *int `json:"gettimeofday_latency,omitempty"`

		// JobStatesTs Job states timestamp
		JobStatesTs *int `json:"job_states_ts,omitempty"`

		// JobsCanceled Job cancelled
		JobsCanceled *int `json:"jobs_canceled,omitempty"`

		// JobsCompleted Job completed
		JobsCompleted *int `json:"jobs_completed,omitempty"`

		// JobsFailed Job failed
		JobsFailed *int `json:"jobs_failed,omitempty"`

		// JobsPending Job pending
		JobsPending *int `json:"jobs_pending,omitempty"`

		// JobsRunning Job running
		JobsRunning *int `json:"jobs_running,omitempty"`

		// JobsStarted Job started
		JobsStarted *int `json:"jobs_started,omitempty"`

		// JobsSubmitted Job submitted
		JobsSubmitted *int `json:"jobs_submitted,omitempty"`

		// PartsPacked partition records packed
		PartsPacked *int `json:"parts_packed,omitempty"`

		// ReqTime generation time
		ReqTime *int `json:"req_time,omitempty"`

		// ReqTimeStart data since
		ReqTimeStart *int `json:"req_time_start,omitempty"`

		// ScheduleCycleLast Main Schedule last cycle
		ScheduleCycleLast *int `json:"schedule_cycle_last,omitempty"`

		// ScheduleCycleMax Main Schedule max cycle
		ScheduleCycleMax *int `json:"schedule_cycle_max,omitempty"`

		// ScheduleCycleMean Average time for Schedule Max cycle
		ScheduleCycleMean *int `json:"schedule_cycle_mean,omitempty"`

		// ScheduleCycleMeanDepth Average depth for Schedule Max cycle
		ScheduleCycleMeanDepth *int `json:"schedule_cycle_mean_depth,omitempty"`

		// ScheduleCyclePerMinute Main Schedule Cycles per minute
		ScheduleCyclePerMinute *int `json:"schedule_cycle_per_minute,omitempty"`

		// ScheduleCycleTotal Main Schedule cycle iterations
		ScheduleCycleTotal *int `json:"schedule_cycle_total,omitempty"`

		// ScheduleQueueLength Main Schedule Last queue length
		ScheduleQueueLength *int `json:"schedule_queue_length,omitempty"`

		// ServerThreadCount Server thread count
		ServerThreadCount *int `json:"server_thread_count,omitempty"`
	} `json:"statistics,omitempty"`
}

// V0037Error defines model for v0.0.37_error.
type V0037Error struct {
	// Errno error number
	Errno *int `json:"errno,omitempty"`

	// Error error message
	Error *string `json:"error,omitempty"`
}

// V0037JobProperties defines model for v0.0.37_job_properties.
type V0037JobProperties struct {
	// Account Charge resources used by this job to specified account.
	Account *string `json:"account,omitempty"`

	// AccountGatherFreqency Define the job accounting and profiling sampling intervals.
	AccountGatherFreqency *string `json:"account_gather_freqency,omitempty"`

	// Argv Arguments to the script.
	Argv *[]string `json:"argv,omitempty"`

	// Array Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
	Array *string `json:"array,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
	BeginTime *int64 `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specification.
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraints Specifies features that a federated cluster must have to have a sibling job submitted to it.
	ClusterConstraints *string `json:"cluster_constraints,omitempty"`

	// Comment An arbitrary comment.
	Comment *string `json:"comment,omitempty"`

	// Constraints node features required by job.
	Constraints *string `json:"constraints,omitempty"`

	// CoreSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	CoreSpecification *int `json:"core_specification,omitempty"`

	// CoresPerSocket Restrict node selection to nodes with at least the specified number of cores per socket.
	CoresPerSocket *int `json:"cores_per_socket,omitempty"`

	// CpuBinding Cpu binding
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingHint Cpu binding hint
	CpuBindingHint *string `json:"cpu_binding_hint,omitempty"`

	// CpuFrequency Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerGpu Number of CPUs requested per allocated GPU.
	CpusPerGpu *string `json:"cpus_per_gpu,omitempty"`

	// CpusPerTask Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
	CpusPerTask *int `json:"cpus_per_task,omitempty"`

	// CurrentWorkingDirectory Instruct Slurm to connect the batch script's standard output directly to the file name.
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])). (Unix timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Do not reboot nodes in order to satisfied this job's feature specification if the job has been eligible to run for less than this time period.
	DelayBoot *int `json:"delay_boot,omitempty"`

	// Dependency Defer the start of this job until the specified dependencies have been satisfied completed.
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Specify alternate distribution methods for remote processes.
	Distribution *string `json:"distribution,omitempty"`

	// Environment Dictionary of environment entries.
	Environment map[string]interface{} `json:"environment"`

	// Exclusive The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
	Exclusive *V0037JobPropertiesExclusive `json:"exclusive,omitempty"`

	// GetUserEnvironment Load new login environment for user on job node.
	GetUserEnvironment *bool `json:"get_user_environment,omitempty"`

	// GpuBinding Requested binding of tasks to GPU.
	GpuBinding *string `json:"gpu_binding,omitempty"`

	// GpuFrequency Requested GPU frequency.
	GpuFrequency *string `json:"gpu_frequency,omitempty"`

	// Gpus GPUs per job.
	Gpus *string `json:"gpus,omitempty"`

	// GpusPerNode GPUs per node.
	GpusPerNode *string `json:"gpus_per_node,omitempty"`

	// GpusPerSocket GPUs per socket.
	GpusPerSocket *string `json:"gpus_per_socket,omitempty"`

	// GpusPerTask GPUs per task.
	GpusPerTask *string `json:"gpus_per_task,omitempty"`

	// Gres Specifies a comma delimited list of generic consumable resources.
	Gres *string `json:"gres,omitempty"`

	// GresFlags Specify generic resource task binding options.
	GresFlags *V0037JobPropertiesGresFlags `json:"gres_flags,omitempty"`

	// Hold Specify the job is to be submitted in a held state (priority of zero).
	Hold *bool `json:"hold,omitempty"`

	// KillOnInvalidDependency If a job has an invalid dependency, then Slurm is to terminate it.
	KillOnInvalidDependency *bool `json:"kill_on_invalid_dependency,omitempty"`

	// Licenses Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
	Licenses *string `json:"licenses,omitempty"`

	// MailType Notify user by email when certain event types occur.
	MailType *string `json:"mail_type,omitempty"`

	// MailUser User to receive email notification of state changes as defined by mail_type.
	MailUser *string `json:"mail_user,omitempty"`

	// McsLabel This parameter is a group among the groups of the user.
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Bind tasks to memory.
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryPerCpu Minimum real memory per cpu (MB).
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// MemoryPerGpu Minimum memory required per allocated GPU.
	MemoryPerGpu *int `json:"memory_per_gpu,omitempty"`

	// MemoryPerNode Minimum real memory per node (MB).
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node.
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes If a range of node counts is given, prefer the smaller count.
	MinimumNodes *bool `json:"minimum_nodes,omitempty"`

	// Name Specify a name for the job allocation.
	Name *string `json:"name,omitempty"`

	// Nice Run the job with an adjusted scheduling priority within Slurm.
	Nice *string `json:"nice,omitempty"`

	// NoKill Do not automatically terminate a job if one of the nodes it has been allocated fails.
	NoKill *bool `json:"no_kill,omitempty"`

	// Nodes Request that a minimum of minnodes nodes and a maximum node count.
	Nodes *[]int `json:"nodes,omitempty"`

	// OpenMode Open the output and error files using append or truncate mode as specified.
	OpenMode *V0037JobPropertiesOpenMode `json:"open_mode,omitempty"`

	// Partition Request a specific partition for the resource allocation.
	Partition *string `json:"partition,omitempty"`

	// Priority Request a specific job priority.
	Priority *int `json:"priority,omitempty"`

	// Qos Request a quality of service for the job.
	Qos *string `json:"qos,omitempty"`

	// Requeue Specifies that the batch job should eligible to being requeue.
	Requeue *bool `json:"requeue,omitempty"`

	// Reservation Allocate resources for the job from the named reservation.
	Reservation *string `json:"reservation,omitempty"`

	// Signal When a job is within sig_time seconds of its end time, send it the signal sig_num.
	Signal *string `json:"signal,omitempty"`

	// SocketsPerNode Restrict node selection to nodes with at least the specified number of sockets.
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// SpreadJob Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
	SpreadJob *bool `json:"spread_job,omitempty"`

	// StandardError Instruct Slurm to connect the batch script's standard error directly to the file name.
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Instruct Slurm to connect the batch script's standard input directly to the file name specified.
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Instruct Slurm to connect the batch script's standard output directly to the file name.
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerCore Request the maximum ntasks be invoked on each core.
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// TasksPerNode Request the maximum ntasks be invoked on each node.
	TasksPerNode *int `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Request the maximum ntasks be invoked on each socket.
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// ThreadSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	ThreadSpecification *int `json:"thread_specification,omitempty"`

	// ThreadsPerCore Restrict node selection to nodes with at least the specified number of threads per core.
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// TimeLimit Step time limit.
	TimeLimit *int `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes.
	TimeMinimum *int `json:"time_minimum,omitempty"`

	// WaitAllNodes Do not begin execution until all nodes are ready for use.
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// Wckey Specify wckey to be used with job.
	Wckey *string `json:"wckey,omitempty"`
}

// V0037JobPropertiesExclusive The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
type V0037JobPropertiesExclusive string

// V0037JobPropertiesGresFlags Specify generic resource task binding options.
type V0037JobPropertiesGresFlags string

// V0037JobPropertiesOpenMode Open the output and error files using append or truncate mode as specified.
type V0037JobPropertiesOpenMode string

// V0037JobResources defines model for v0.0.37_job_resources.
type V0037JobResources struct {
	// AllocatedCpus number of assigned job cpus
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// AllocatedHosts number of assigned job hosts
	AllocatedHosts *int `json:"allocated_hosts,omitempty"`

	// AllocatedNodes node allocations (map with node indices as keys)
	AllocatedNodes *map[string]V0037NodeAllocation `json:"allocated_nodes,omitempty"`

	// Nodes list of assigned job nodes
	Nodes *string `json:"nodes,omitempty"`
}

// V0037JobResponseProperties defines model for v0.0.37_job_response_properties.
type V0037JobResponseProperties struct {
	// Account Charge resources used by this job to specified account
	Account *string `json:"account,omitempty"`

	// AccrueTime time job is eligible for running
	AccrueTime *int64 `json:"accrue_time,omitempty"`

	// AdminComment administrator's arbitrary comment
	AdminComment *string `json:"admin_comment,omitempty"`

	// ArrayJobId job_id of a job array or 0 if N/A
	ArrayJobId *int `json:"array_job_id,omitempty"`

	// ArrayMaxTasks Maximum number of running array tasks
	ArrayMaxTasks *int `json:"array_max_tasks,omitempty"`

	// ArrayTaskId task_id of a job array
	ArrayTaskId *int `json:"array_task_id,omitempty"`

	// ArrayTaskString string expression of task IDs in this record
	ArrayTaskString *string `json:"array_task_string,omitempty"`

	// AssociationId association id for job
	AssociationId *int `json:"association_id,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BatchFlag if batch: queued job with script
	BatchFlag *bool `json:"batch_flag,omitempty"`

	// BatchHost name of host running batch script
	BatchHost *string `json:"batch_host,omitempty"`

	// BillableTres billable TRES
	BillableTres *float64 `json:"billable_tres,omitempty"`

	// BurstBuffer burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// BurstBufferState burst buffer state info
	BurstBufferState *string `json:"burst_buffer_state,omitempty"`

	// Cluster name of cluster that the job is on
	Cluster *string `json:"cluster,omitempty"`

	// ClusterFeatures comma separated list of required cluster features
	ClusterFeatures *string `json:"cluster_features,omitempty"`

	// Command command to be executed
	Command *string `json:"command,omitempty"`

	// Comment arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Contiguous job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpec specialized core count
	CoreSpec *string `json:"core_spec,omitempty"`

	// CoresPerSocket cores per socket required by job
	CoresPerSocket *string `json:"cores_per_socket,omitempty"`

	// CpuFrequencyGovernor cpu frequency governor
	CpuFrequencyGovernor *string `json:"cpu_frequency_governor,omitempty"`

	// CpuFrequencyMaximum Maximum cpu frequency
	CpuFrequencyMaximum *string `json:"cpu_frequency_maximum,omitempty"`

	// CpuFrequencyMinimum Minimum cpu frequency
	CpuFrequencyMinimum *string `json:"cpu_frequency_minimum,omitempty"`

	// Cpus minimum number of cpus required by job
	Cpus *int `json:"cpus,omitempty"`

	// CpusPerTask number of processors required for each task
	CpusPerTask *string `json:"cpus_per_task,omitempty"`

	// CpusPerTres semicolon delimited list of TRES=# values
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// CurrentWorkingDirectory pathname of working directory
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline job start deadline  (Unix timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot command to be executed (Unix timestamp)
	DelayBoot *int64 `json:"delay_boot,omitempty"`

	// Dependency synchronize job execution with other jobs
	Dependency *string `json:"dependency,omitempty"`

	// DerivedExitCode highest exit code of all job steps
	DerivedExitCode *int `json:"derived_exit_code,omitempty"`

	// EligibleTime time job is eligible for running
	EligibleTime *int64 `json:"eligible_time,omitempty"`

	// EndTime time of termination, actual or expected
	EndTime *int64 `json:"end_time,omitempty"`

	// ExcludedNodes comma separated list of excluded nodes
	ExcludedNodes *string `json:"excluded_nodes,omitempty"`

	// ExitCode exit code for job
	ExitCode *int `json:"exit_code,omitempty"`

	// Features comma separated list of required features
	Features *string `json:"features,omitempty"`

	// FederationOrigin Origin cluster's name
	FederationOrigin *string `json:"federation_origin,omitempty"`

	// FederationSiblingsActive string of active sibling names
	FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

	// FederationSiblingsViable string of viable sibling names
	FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

	// Flags Job flags
	Flags *[]string `json:"flags,omitempty"`

	// GresDetail Job flags
	GresDetail *[]string `json:"gres_detail,omitempty"`

	// GroupId group job submitted as
	GroupId *int `json:"group_id,omitempty"`

	// HetJobId job ID of hetjob leader
	HetJobId *int `json:"het_job_id,omitempty"`

	// HetJobIdSet job IDs for all components
	HetJobIdSet *string `json:"het_job_id_set,omitempty"`

	// HetJobOffset HetJob component offset from leader
	HetJobOffset *int `json:"het_job_offset,omitempty"`

	// JobId job ID
	JobId *int `json:"job_id,omitempty"`

	// JobState state of the job
	JobState *string `json:"job_state,omitempty"`

	// LastSchedEvaluation last time job was evaluated for scheduling (Unix timestamp)
	LastSchedEvaluation *int64 `json:"last_sched_evaluation,omitempty"`

	// Licenses licenses required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MaxCpus maximum number of cpus usable by job
	MaxCpus *int `json:"max_cpus,omitempty"`

	// MaxNodes maximum number of nodes usable by job
	MaxNodes *int `json:"max_nodes,omitempty"`

	// McsLabel mcs_label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryPerCpu minimum real memory per cpu
	MemoryPerCpu *string `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode minimum real memory per node
	MemoryPerNode *string `json:"memory_per_node,omitempty"`

	// MemoryPerTres semicolon delimited list of TRES=# values
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumCpusPerNode minimum # CPUs per node
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumTmpDiskPerNode minimum tmp disk per node
	MinimumTmpDiskPerNode *int `json:"minimum_tmp_disk_per_node,omitempty"`

	// Name name of the job
	Name *string `json:"name,omitempty"`

	// Nice requested priority change
	Nice *string `json:"nice,omitempty"`

	// NodeCount minimum number of nodes required by job
	NodeCount *int `json:"node_count,omitempty"`

	// Nodes list of nodes allocated to job
	Nodes *string `json:"nodes,omitempty"`

	// Partition name of assigned partition
	Partition *string `json:"partition,omitempty"`

	// PreSusTime time job ran prior to last suspend
	PreSusTime *int64 `json:"pre_sus_time,omitempty"`

	// PreemptTime preemption signal time
	PreemptTime *int64 `json:"preempt_time,omitempty"`

	// Priority relative priority of the job
	Priority *int `json:"priority,omitempty"`

	// Profile Job profiling requested
	Profile *[]string `json:"profile,omitempty"`

	// Qos Quality of Service
	Qos *string `json:"qos,omitempty"`

	// Reboot node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue enable or disable job requeue option
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes comma separated list of required nodes
	RequiredNodes *string `json:"required_nodes,omitempty"`

	// ResizeTime time of latest size change
	ResizeTime *int64 `json:"resize_time,omitempty"`

	// RestartCnt count of job restarts
	RestartCnt *int `json:"restart_cnt,omitempty"`

	// ResvName reservation name
	ResvName *string `json:"resv_name,omitempty"`

	// Shared type and if job can share nodes with other jobs
	Shared *int `json:"shared,omitempty"`

	// ShowFlags details requested
	ShowFlags *[]string `json:"show_flags,omitempty"`

	// SocketsPerBoard sockets per board required by job
	SocketsPerBoard *int `json:"sockets_per_board,omitempty"`

	// SocketsPerNode sockets per node required by job
	SocketsPerNode *string `json:"sockets_per_node,omitempty"`

	// StandardError pathname of job's stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput pathname of job's stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput pathname of job's stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// StartTime time execution begins, actual or expected
	StartTime *int64 `json:"start_time,omitempty"`

	// StateDescription optional details for state_reason
	StateDescription *string `json:"state_description,omitempty"`

	// StateReason reason job still pending or failed
	StateReason *string `json:"state_reason,omitempty"`

	// SubmitTime time of job submission
	SubmitTime *int64 `json:"submit_time,omitempty"`

	// SuspendTime time job last suspended or resumed
	SuspendTime *int64 `json:"suspend_time,omitempty"`

	// SystemComment slurmctld's arbitrary comment
	SystemComment *string `json:"system_comment,omitempty"`

	// Tasks requested task count
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerBoard number of tasks to invoke on each board
	TasksPerBoard *int `json:"tasks_per_board,omitempty"`

	// TasksPerCore number of tasks to invoke on each core
	TasksPerCore *string `json:"tasks_per_core,omitempty"`

	// TasksPerSocket number of tasks to invoke on each socket
	TasksPerSocket *string `json:"tasks_per_socket,omitempty"`

	// ThreadSpec specialized thread count
	ThreadSpec *string `json:"thread_spec,omitempty"`

	// ThreadsPerCore threads per core required by job
	ThreadsPerCore *string `json:"threads_per_core,omitempty"`

	// TimeLimit maximum run time in minutes (Unix timestamp)
	TimeLimit *int64 `json:"time_limit,omitempty"`

	// TimeMinimum minimum run time in minutes (Unix timestamp)
	TimeMinimum *int64 `json:"time_minimum,omitempty"`

	// TresAllocStr tres used in the job
	TresAllocStr *string `json:"tres_alloc_str,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob semicolon delimited list of TRES=# values
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode semicolon delimited list of TRES=# values
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket semicolon delimited list of TRES=# values
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask semicolon delimited list of TRES=# values
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// TresReqStr tres reqeusted in the job
	TresReqStr *string `json:"tres_req_str,omitempty"`

	// UserId user id the job runs as
	UserId *int `json:"user_id,omitempty"`

	// UserName user the job runs as
	UserName *string `json:"user_name,omitempty"`

	// Wckey wckey for job
	Wckey *string `json:"wckey,omitempty"`
}

// V0037JobSubmission defines model for v0.0.37_job_submission.
type V0037JobSubmission struct {
	Job *V0037JobProperties `json:"job,omitempty"`

	// Jobs Properties of an HetJob
	Jobs *[]V0037JobProperties `json:"jobs,omitempty"`

	// Script Executable script (full contents) to run in batch step
	Script string `json:"script"`
}

// V0037JobSubmissionResponse defines model for v0.0.37_job_submission_response.
type V0037JobSubmissionResponse struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// JobId new job ID
	JobId *int `json:"job_id,omitempty"`

	// JobSubmitUserMsg Message to user from job_submit plugin
	JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

	// StepId new job step ID
	StepId *string `json:"step_id,omitempty"`
}

// V0037JobsResponse defines model for v0.0.37_jobs_response.
type V0037JobsResponse struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// Jobs job descriptions
	Jobs *[]V0037JobResponseProperties `json:"jobs,omitempty"`
}

// V0037Node defines model for v0.0.37_node.
type V0037Node struct {
	// ActiveFeatures list of a node's available features
	ActiveFeatures *string `json:"active_features,omitempty"`

	// Address state after reboot
	Address *string `json:"address,omitempty"`

	// AllocCpus Allocated CPUs
	AllocCpus *int64 `json:"alloc_cpus,omitempty"`

	// AllocMemory Allocated memory (MB)
	AllocMemory *int64 `json:"alloc_memory,omitempty"`

	// Architecture computer architecture
	Architecture *string `json:"architecture,omitempty"`

	// Boards total number of boards per node
	Boards *int `json:"boards,omitempty"`

	// BootTime timestamp of node boot
	BootTime *int64 `json:"boot_time,omitempty"`

	// BurstbufferNetworkAddress BcastAddr
	BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

	// Cores number of cores per socket
	Cores *int `json:"cores,omitempty"`

	// CpuBinding Default task binding
	CpuBinding *int `json:"cpu_binding,omitempty"`

	// CpuLoad CPU load * 100
	CpuLoad *int64 `json:"cpu_load,omitempty"`

	// Cpus configured count of cpus running on the node
	Cpus     *int    `json:"cpus,omitempty"`
	Features *string `json:"features,omitempty"`

	// FreeMemory free memory in MiB
	FreeMemory *int `json:"free_memory,omitempty"`

	// Gres list of a node's generic resources
	Gres *string `json:"gres,omitempty"`

	// GresDrained list of drained GRES
	GresDrained *string `json:"gres_drained,omitempty"`

	// GresUsed list of GRES in current use
	GresUsed *string `json:"gres_used,omitempty"`

	// Hostname node's hostname
	Hostname *string `json:"hostname,omitempty"`

	// IdleCpus Idle CPUs
	IdleCpus *int64 `json:"idle_cpus,omitempty"`

	// McsLabel mcs label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// Name node name to slurm
	Name *string `json:"name,omitempty"`

	// NextStateAfterReboot state after reboot
	NextStateAfterReboot *string `json:"next_state_after_reboot,omitempty"`

	// NextStateAfterRebootFlags node state flags
	NextStateAfterRebootFlags *[]string `json:"next_state_after_reboot_flags,omitempty"`

	// OperatingSystem operating system
	OperatingSystem *string `json:"operating_system,omitempty"`

	// Owner User allowed to use this node
	Owner *string `json:"owner,omitempty"`

	// Partitions assigned partitions
	Partitions *[]string `json:"partitions,omitempty"`

	// Port TCP port number of the slurmd
	Port *int `json:"port,omitempty"`

	// RealMemory configured MB of real memory on the node
	RealMemory *int `json:"real_memory,omitempty"`

	// Reason reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonChangedAt Time stamp when reason was set
	ReasonChangedAt *int `json:"reason_changed_at,omitempty"`

	// ReasonSetByUser User that set the reason
	ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

	// SlurmdStartTime timestamp of slurmd startup
	SlurmdStartTime *int64 `json:"slurmd_start_time,omitempty"`

	// SlurmdVersion Slurmd version
	SlurmdVersion *string `json:"slurmd_version,omitempty"`

	// Sockets total number of sockets per node
	Sockets *int `json:"sockets,omitempty"`

	// State current node state
	State *string `json:"state,omitempty"`

	// StateFlags node state flags
	StateFlags *[]string `json:"state_flags,omitempty"`

	// TemporaryDisk configured MB of total disk in TMP_FS
	TemporaryDisk *int `json:"temporary_disk,omitempty"`

	// Threads number of threads per core
	Threads *int `json:"threads,omitempty"`

	// Tres TRES on node
	Tres *string `json:"tres,omitempty"`

	// TresUsed TRES used on node
	TresUsed *string `json:"tres_used,omitempty"`

	// TresWeighted TRES weight used on node
	TresWeighted *float64 `json:"tres_weighted,omitempty"`

	// Weight arbitrary priority of node for scheduling
	Weight *int `json:"weight,omitempty"`
}

// V0037NodeAllocation defines model for v0.0.37_node_allocation.
type V0037NodeAllocation struct {
	// Cores assignment status of each core by core id
	Cores *map[string]interface{} `json:"cores,omitempty"`

	// Cpus amount of assigned job CPUs
	Cpus *map[string]interface{} `json:"cpus,omitempty"`

	// Memory amount of assigned job memory
	Memory *int `json:"memory,omitempty"`

	// Sockets assignment status of each socket by socket id
	Sockets *map[string]interface{} `json:"sockets,omitempty"`
}

// V0037NodesResponse defines model for v0.0.37_nodes_response.
type V0037NodesResponse struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// Nodes nodes info
	Nodes *[]V0037Node `json:"nodes,omitempty"`
}

// V0037Partition defines model for v0.0.37_partition.
type V0037Partition struct {
	// AllowedAccounts comma delimited list of accounts
	AllowedAccounts *string `json:"allowed_accounts,omitempty"`

	// AllowedAllocationNodes list names of allowed allocating nodes
	AllowedAllocationNodes *string `json:"allowed_allocation_nodes,omitempty"`

	// AllowedGroups comma delimited list of groups
	AllowedGroups *string `json:"allowed_groups,omitempty"`

	// AllowedQos comma delimited list of qos
	AllowedQos *string `json:"allowed_qos,omitempty"`

	// Alternative name of alternate partition
	Alternative *string `json:"alternative,omitempty"`

	// BillingWeights TRES billing weights
	BillingWeights *string `json:"billing_weights,omitempty"`

	// DefaultMemoryPerCpu default MB memory per allocated CPU
	DefaultMemoryPerCpu *int64 `json:"default_memory_per_cpu,omitempty"`

	// DefaultTimeLimit default time limit (minutes)
	DefaultTimeLimit *int64 `json:"default_time_limit,omitempty"`

	// DeniedAccounts comma delimited list of denied accounts
	DeniedAccounts *string `json:"denied_accounts,omitempty"`

	// DeniedQos comma delimited list of denied qos
	DeniedQos *string `json:"denied_qos,omitempty"`

	// Flags partition options
	Flags *[]string `json:"flags,omitempty"`

	// MaxTimeLimit Max time limit per job
	MaxTimeLimit *int64 `json:"max_time_limit,omitempty"`

	// MaximumCpusPerNode maximum allocated CPUs per node
	MaximumCpusPerNode *int `json:"maximum_cpus_per_node,omitempty"`

	// MaximumMemoryPerNode maximum memory per allocated CPU (MiB)
	MaximumMemoryPerNode *int64 `json:"maximum_memory_per_node,omitempty"`

	// MaximumNodesPerJob Max nodes per job
	MaximumNodesPerJob *int `json:"maximum_nodes_per_job,omitempty"`

	// MinNodesPerJob Min number of nodes per job
	MinNodesPerJob *int `json:"min_nodes_per_job,omitempty"`

	// Name Partition name
	Name *string `json:"name,omitempty"`

	// Nodes list names of nodes in partition
	Nodes *string `json:"nodes,omitempty"`

	// OverTimeLimit job's time limit can be exceeded by this number of minutes before cancellation
	OverTimeLimit *int `json:"over_time_limit,omitempty"`

	// PreemptionGraceTime preemption grace time (seconds)
	PreemptionGraceTime *int64 `json:"preemption_grace_time,omitempty"`

	// PreemptionMode preemption type
	PreemptionMode *[]string `json:"preemption_mode,omitempty"`

	// PriorityJobFactor job priority weight factor
	PriorityJobFactor *int `json:"priority_job_factor,omitempty"`

	// PriorityTier tier for scheduling and preemption
	PriorityTier *int `json:"priority_tier,omitempty"`

	// Qos partition QOS name
	Qos *string `json:"qos,omitempty"`

	// State Partition state
	State *string `json:"state,omitempty"`

	// TotalCpus Total cpus in partition
	TotalCpus *int `json:"total_cpus,omitempty"`

	// TotalNodes Total number of nodes in partition
	TotalNodes *int `json:"total_nodes,omitempty"`

	// Tres configured TRES in partition
	Tres *string `json:"tres,omitempty"`
}

// V0037PartitionsResponse defines model for v0.0.37_partitions_response.
type V0037PartitionsResponse struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// Partitions partition info
	Partitions *[]V0037Partition `json:"partitions,omitempty"`
}

// V0037Ping defines model for v0.0.37_ping.
type V0037Ping struct {
	// Hostname slurm controller hostname
	Hostname *string `json:"hostname,omitempty"`

	// Mode slurm controller mode
	Mode *string `json:"mode,omitempty"`

	// Ping slurm controller host up
	Ping *V0037PingPing `json:"ping,omitempty"`

	// Status slurm controller status
	Status *int `json:"status,omitempty"`
}

// V0037PingPing slurm controller host up
type V0037PingPing string

// V0037Pings defines model for v0.0.37_pings.
type V0037Pings struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// Pings slurm controller pings
	Pings *[]V0037Ping `json:"pings,omitempty"`
}

// V0037Reservation defines model for v0.0.37_reservation.
type V0037Reservation struct {
	// Accounts Allowed accounts
	Accounts *string `json:"accounts,omitempty"`

	// BurstBuffer Reserved burst buffer
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// CoreCount Number of reserved cores
	CoreCount *int `json:"core_count,omitempty"`

	// CoreSpecCnt Number of reserved specialized cores
	CoreSpecCnt *int `json:"core_spec_cnt,omitempty"`

	// EndTime End time of the reservation
	EndTime *int `json:"end_time,omitempty"`

	// Features List of features
	Features *string `json:"features,omitempty"`

	// Flags Reservation options
	Flags *[]string `json:"flags,omitempty"`

	// Groups List of groups permitted to use the reserved nodes
	Groups *string `json:"groups,omitempty"`

	// Licenses List of licenses
	Licenses *string `json:"licenses,omitempty"`

	// MaxStartDelay Maximum delay in which jobs outside of the reservation will be permitted to overlap once any jobs are queued for the reservation
	MaxStartDelay *int `json:"max_start_delay,omitempty"`

	// Name Reservationn name
	Name *string `json:"name,omitempty"`

	// NodeCount Count of nodes reserved
	NodeCount *int `json:"node_count,omitempty"`

	// NodeList List of reserved nodes
	NodeList *string `json:"node_list,omitempty"`

	// Partition Partition
	Partition *string `json:"partition,omitempty"`

	// PurgeCompleted If PURGE_COMP flag is set the amount of seconds this reservation will sit idle until it is revoked
	PurgeCompleted *struct {
		// Time amount of seconds this reservation will sit idle until it is revoked
		Time *int `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`

	// StartTime Start time of reservation
	StartTime *int `json:"start_time,omitempty"`

	// Tres List of TRES
	Tres *string `json:"tres,omitempty"`

	// Users List of users
	Users *string `json:"users,omitempty"`

	// Watts amount of power to reserve in watts
	Watts *int `json:"watts,omitempty"`
}

// V0037ReservationsResponse defines model for v0.0.37_reservations_response.
type V0037ReservationsResponse struct {
	// Errors slurm errors
	Errors *[]V0037Error `json:"errors,omitempty"`

	// Reservations reservation info
	Reservations *[]V0037Reservation `json:"reservations,omitempty"`
}

// V0037Signal POSIX signal name
type V0037Signal string

// SlurmctldCancelJobParams defines parameters for SlurmctldCancelJob.
type SlurmctldCancelJobParams struct {
	// Signal signal to send to job
	Signal *V0037Signal `form:"signal,omitempty" json:"signal,omitempty"`
}

// SlurmctldGetJobsParams defines parameters for SlurmctldGetJobs.
type SlurmctldGetJobsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `json:"update_time,omitempty"`
}

// SlurmctldGetNodesParams defines parameters for SlurmctldGetNodes.
type SlurmctldGetNodesParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `json:"update_time,omitempty"`
}

// SlurmctldGetPartitionParams defines parameters for SlurmctldGetPartition.
type SlurmctldGetPartitionParams struct {
	// UpdateTime Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
	UpdateTime *int64 `json:"update_time,omitempty"`
}

// SlurmctldGetPartitionsParams defines parameters for SlurmctldGetPartitions.
type SlurmctldGetPartitionsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `json:"update_time,omitempty"`
}

// SlurmctldGetReservationParams defines parameters for SlurmctldGetReservation.
type SlurmctldGetReservationParams struct {
	// UpdateTime Filter if no reservation (not limited to reservation in URL) changed since update_time.
	UpdateTime *int64 `json:"update_time,omitempty"`
}

// SlurmctldGetReservationsParams defines parameters for SlurmctldGetReservations.
type SlurmctldGetReservationsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `json:"update_time,omitempty"`
}

// SlurmdbdDeleteAssociationParams defines parameters for SlurmdbdDeleteAssociation.
type SlurmdbdDeleteAssociationParams struct {
	// Cluster Cluster name
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Account Account name
	Account string `form:"account" json:"account"`

	// User User name
	User string `form:"user" json:"user"`

	// Partition Partition Name
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`
}

// SlurmdbdGetAssociationParams defines parameters for SlurmdbdGetAssociation.
type SlurmdbdGetAssociationParams struct {
	// Cluster Cluster name
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Account Account name
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// User User name
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Partition Partition Name
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`
}

// SlurmdbdGetJobsParams defines parameters for SlurmdbdGetJobs.
type SlurmdbdGetJobsParams struct {
	// SubmitTime Filter by submission time
	//  Accepted formats:
	//  HH:MM[:SS] [AM|PM]
	// MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]
	// MM/DD[/YY]-HH:MM[:SS]
	// YYYY-MM-DD[THH:MM[:SS]]
	SubmitTime *string `form:"submit_time,omitempty" json:"submit_time,omitempty"`

	// StartTime Filter by start time
	//  Accepted formats:
	//  HH:MM[:SS] [AM|PM]
	// MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]
	// MM/DD[/YY]-HH:MM[:SS]
	// YYYY-MM-DD[THH:MM[:SS]]
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime Filter by end time
	//  Accepted formats:
	//  HH:MM[:SS] [AM|PM]
	// MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]
	// MM/DD[/YY]-HH:MM[:SS]
	// YYYY-MM-DD[THH:MM[:SS]]
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Account Comma delimited list of accounts to match
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Association Comma delimited list of associations to match
	Association *string `form:"association,omitempty" json:"association,omitempty"`

	// Cluster Comma delimited list of cluster to match
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Constraints Comma delimited list of constraints to match
	Constraints *string `form:"constraints,omitempty" json:"constraints,omitempty"`

	// CpusMax Number of CPUs high range
	CpusMax *string `form:"cpus_max,omitempty" json:"cpus_max,omitempty"`

	// CpusMin Number of CPUs low range
	CpusMin *string `form:"cpus_min,omitempty" json:"cpus_min,omitempty"`

	// SkipSteps Report job step information
	SkipSteps *bool `form:"skip_steps,omitempty" json:"skip_steps,omitempty"`

	// DisableWaitForResult Disable waiting for result from slurmdbd
	DisableWaitForResult *bool `form:"disable_wait_for_result,omitempty" json:"disable_wait_for_result,omitempty"`

	// ExitCode Exit code of job
	ExitCode *string `form:"exit_code,omitempty" json:"exit_code,omitempty"`

	// Format Comma delimited list of formats to match
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Group Comma delimited list of groups to match
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// JobName Comma delimited list of job names to match
	JobName *string `form:"job_name,omitempty" json:"job_name,omitempty"`

	// NodesMax Number of nodes high range
	NodesMax *string `form:"nodes_max,omitempty" json:"nodes_max,omitempty"`

	// NodesMin Number of nodes low range
	NodesMin *string `form:"nodes_min,omitempty" json:"nodes_min,omitempty"`

	// Partition Comma delimited list of partitions to match
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos Comma delimited list of QOS to match
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// Reason Comma delimited list of job reasons to match
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Reservation Comma delimited list of reservations to match
	Reservation *string `form:"reservation,omitempty" json:"reservation,omitempty"`

	// State Comma delimited list of states to match
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Step Comma delimited list of job steps to match
	Step *string `form:"step,omitempty" json:"step,omitempty"`

	// Node Comma delimited list of used nodes to match
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Wckey Comma delimited list of wckeys to match
	Wckey *string `form:"wckey,omitempty" json:"wckey,omitempty"`
}

// SlurmctldSubmitJobJSONRequestBody defines body for SlurmctldSubmitJob for application/json ContentType.
type SlurmctldSubmitJobJSONRequestBody = V0037JobSubmission

// SlurmctldUpdateJobJSONRequestBody defines body for SlurmctldUpdateJob for application/json ContentType.
type SlurmctldUpdateJobJSONRequestBody = V0037JobProperties

// AsJobPropertiesExclusive0 returns the union data inside the JobProperties_Exclusive as a JobPropertiesExclusive0
func (t JobProperties_Exclusive) AsJobPropertiesExclusive0() (JobPropertiesExclusive0, error) {
	var body JobPropertiesExclusive0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobPropertiesExclusive0 overwrites any union data inside the JobProperties_Exclusive as the provided JobPropertiesExclusive0
func (t *JobProperties_Exclusive) FromJobPropertiesExclusive0(v JobPropertiesExclusive0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobPropertiesExclusive0 performs a merge with any union data inside the JobProperties_Exclusive, using the provided JobPropertiesExclusive0
func (t *JobProperties_Exclusive) MergeJobPropertiesExclusive0(v JobPropertiesExclusive0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJobPropertiesExclusive1 returns the union data inside the JobProperties_Exclusive as a JobPropertiesExclusive1
func (t JobProperties_Exclusive) AsJobPropertiesExclusive1() (JobPropertiesExclusive1, error) {
	var body JobPropertiesExclusive1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobPropertiesExclusive1 overwrites any union data inside the JobProperties_Exclusive as the provided JobPropertiesExclusive1
func (t *JobProperties_Exclusive) FromJobPropertiesExclusive1(v JobPropertiesExclusive1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobPropertiesExclusive1 performs a merge with any union data inside the JobProperties_Exclusive, using the provided JobPropertiesExclusive1
func (t *JobProperties_Exclusive) MergeJobPropertiesExclusive1(v JobPropertiesExclusive1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobProperties_Exclusive) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobProperties_Exclusive) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJobPropertiesNodes0 returns the union data inside the JobProperties_Nodes as a JobPropertiesNodes0
func (t JobProperties_Nodes) AsJobPropertiesNodes0() (JobPropertiesNodes0, error) {
	var body JobPropertiesNodes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobPropertiesNodes0 overwrites any union data inside the JobProperties_Nodes as the provided JobPropertiesNodes0
func (t *JobProperties_Nodes) FromJobPropertiesNodes0(v JobPropertiesNodes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobPropertiesNodes0 performs a merge with any union data inside the JobProperties_Nodes, using the provided JobPropertiesNodes0
func (t *JobProperties_Nodes) MergeJobPropertiesNodes0(v JobPropertiesNodes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJobPropertiesNodes1 returns the union data inside the JobProperties_Nodes as a JobPropertiesNodes1
func (t JobProperties_Nodes) AsJobPropertiesNodes1() (JobPropertiesNodes1, error) {
	var body JobPropertiesNodes1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJobPropertiesNodes1 overwrites any union data inside the JobProperties_Nodes as the provided JobPropertiesNodes1
func (t *JobProperties_Nodes) FromJobPropertiesNodes1(v JobPropertiesNodes1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJobPropertiesNodes1 performs a merge with any union data inside the JobProperties_Nodes, using the provided JobPropertiesNodes1
func (t *JobProperties_Nodes) MergeJobPropertiesNodes1(v JobPropertiesNodes1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JobProperties_Nodes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JobProperties_Nodes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSignal0 returns the union data inside the Signal as a Signal0
func (t Signal) AsSignal0() (Signal0, error) {
	var body Signal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignal0 overwrites any union data inside the Signal as the provided Signal0
func (t *Signal) FromSignal0(v Signal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignal0 performs a merge with any union data inside the Signal, using the provided Signal0
func (t *Signal) MergeSignal0(v Signal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSignal1 returns the union data inside the Signal as a Signal1
func (t Signal) AsSignal1() (Signal1, error) {
	var body Signal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSignal1 overwrites any union data inside the Signal as the provided Signal1
func (t *Signal) FromSignal1(v Signal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSignal1 performs a merge with any union data inside the Signal, using the provided Signal1
func (t *Signal) MergeSignal1(v Signal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Signal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Signal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenapiV3 request
	GetOpenapiV3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldDiag request
	SlurmctldDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldSubmitJobWithBody request with any body
	SlurmctldSubmitJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmctldSubmitJob(ctx context.Context, body SlurmctldSubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldCancelJob request
	SlurmctldCancelJob(ctx context.Context, jobId string, params *SlurmctldCancelJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetJob request
	SlurmctldGetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldUpdateJobWithBody request with any body
	SlurmctldUpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmctldUpdateJob(ctx context.Context, jobId string, body SlurmctldUpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetJobs request
	SlurmctldGetJobs(ctx context.Context, params *SlurmctldGetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetNode request
	SlurmctldGetNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetNodes request
	SlurmctldGetNodes(ctx context.Context, params *SlurmctldGetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetPartition request
	SlurmctldGetPartition(ctx context.Context, partitionName string, params *SlurmctldGetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetPartitions request
	SlurmctldGetPartitions(ctx context.Context, params *SlurmctldGetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldPing request
	SlurmctldPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetReservation request
	SlurmctldGetReservation(ctx context.Context, reservationName string, params *SlurmctldGetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmctldGetReservations request
	SlurmctldGetReservations(ctx context.Context, params *SlurmctldGetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDeleteAccount request
	SlurmdbdDeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetAccount request
	SlurmdbdGetAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetAccounts request
	SlurmdbdGetAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdUpdateAccount request
	SlurmdbdUpdateAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDeleteAssociation request
	SlurmdbdDeleteAssociation(ctx context.Context, params *SlurmdbdDeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetAssociation request
	SlurmdbdGetAssociation(ctx context.Context, params *SlurmdbdGetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetAssociations request
	SlurmdbdGetAssociations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdUpdateAssociations request
	SlurmdbdUpdateAssociations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDeleteCluster request
	SlurmdbdDeleteCluster(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetCluster request
	SlurmdbdGetCluster(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetClusters request
	SlurmdbdGetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdAddClusters request
	SlurmdbdAddClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetDbConfig request
	SlurmdbdGetDbConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdSetDbConfig request
	SlurmdbdSetDbConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDiag request
	SlurmdbdDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetJob request
	SlurmdbdGetJob(ctx context.Context, jobId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetJobs request
	SlurmdbdGetJobs(ctx context.Context, params *SlurmdbdGetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetQos request
	SlurmdbdGetQos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDeleteQos request
	SlurmdbdDeleteQos(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetSingleQos request
	SlurmdbdGetSingleQos(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetTres request
	SlurmdbdGetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdUpdateTres request
	SlurmdbdUpdateTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDeleteUser request
	SlurmdbdDeleteUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetUser request
	SlurmdbdGetUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetUsers request
	SlurmdbdGetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdUpdateUsers request
	SlurmdbdUpdateUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdDeleteWckey request
	SlurmdbdDeleteWckey(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetWckey request
	SlurmdbdGetWckey(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdGetWckeys request
	SlurmdbdGetWckeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbdAddWckeys request
	SlurmdbdAddWckeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenapiV3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiV3Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldSubmitJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldSubmitJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldSubmitJob(ctx context.Context, body SlurmctldSubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldSubmitJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldCancelJob(ctx context.Context, jobId string, params *SlurmctldCancelJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldCancelJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldUpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldUpdateJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldUpdateJob(ctx context.Context, jobId string, body SlurmctldUpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldUpdateJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetJobs(ctx context.Context, params *SlurmctldGetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetNodes(ctx context.Context, params *SlurmctldGetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetPartition(ctx context.Context, partitionName string, params *SlurmctldGetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetPartitions(ctx context.Context, params *SlurmctldGetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetReservation(ctx context.Context, reservationName string, params *SlurmctldGetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmctldGetReservations(ctx context.Context, params *SlurmctldGetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmctldGetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDeleteAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdUpdateAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdUpdateAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDeleteAssociation(ctx context.Context, params *SlurmdbdDeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDeleteAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetAssociation(ctx context.Context, params *SlurmdbdGetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetAssociations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetAssociationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdUpdateAssociations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdUpdateAssociationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDeleteCluster(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDeleteClusterRequest(c.Server, clusterName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetCluster(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetClusterRequest(c.Server, clusterName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdAddClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdAddClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetDbConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetDbConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdSetDbConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdSetDbConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetJob(ctx context.Context, jobId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetJobs(ctx context.Context, params *SlurmdbdGetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetQos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetQosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDeleteQos(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDeleteQosRequest(c.Server, qosName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetSingleQos(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetSingleQosRequest(c.Server, qosName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdUpdateTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdUpdateTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDeleteUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDeleteUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdUpdateUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdUpdateUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdDeleteWckey(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdDeleteWckeyRequest(c.Server, wckey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetWckey(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetWckeyRequest(c.Server, wckey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdGetWckeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdGetWckeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbdAddWckeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbdAddWckeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenapiV3Request generates requests for GetOpenapiV3
func NewGetOpenapiV3Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi/v3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldDiagRequest generates requests for SlurmctldDiag
func NewSlurmctldDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/diag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldSubmitJobRequest calls the generic SlurmctldSubmitJob builder with application/json body
func NewSlurmctldSubmitJobRequest(server string, body SlurmctldSubmitJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmctldSubmitJobRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmctldSubmitJobRequestWithBody generates requests for SlurmctldSubmitJob with any type of body
func NewSlurmctldSubmitJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmctldCancelJobRequest generates requests for SlurmctldCancelJob
func NewSlurmctldCancelJobRequest(server string, jobId string, params *SlurmctldCancelJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetJobRequest generates requests for SlurmctldGetJob
func NewSlurmctldGetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldUpdateJobRequest calls the generic SlurmctldUpdateJob builder with application/json body
func NewSlurmctldUpdateJobRequest(server string, jobId string, body SlurmctldUpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmctldUpdateJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmctldUpdateJobRequestWithBody generates requests for SlurmctldUpdateJob with any type of body
func NewSlurmctldUpdateJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmctldGetJobsRequest generates requests for SlurmctldGetJobs
func NewSlurmctldGetJobsRequest(server string, params *SlurmctldGetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("simple", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetNodeRequest generates requests for SlurmctldGetNode
func NewSlurmctldGetNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetNodesRequest generates requests for SlurmctldGetNodes
func NewSlurmctldGetNodesRequest(server string, params *SlurmctldGetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("simple", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetPartitionRequest generates requests for SlurmctldGetPartition
func NewSlurmctldGetPartitionRequest(server string, partitionName string, params *SlurmctldGetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("simple", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetPartitionsRequest generates requests for SlurmctldGetPartitions
func NewSlurmctldGetPartitionsRequest(server string, params *SlurmctldGetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/partitions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("simple", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldPingRequest generates requests for SlurmctldPing
func NewSlurmctldPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetReservationRequest generates requests for SlurmctldGetReservation
func NewSlurmctldGetReservationRequest(server string, reservationName string, params *SlurmctldGetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("simple", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmctldGetReservationsRequest generates requests for SlurmctldGetReservations
func NewSlurmctldGetReservationsRequest(server string, params *SlurmctldGetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.37/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("simple", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDeleteAccountRequest generates requests for SlurmdbdDeleteAccount
func NewSlurmdbdDeleteAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetAccountRequest generates requests for SlurmdbdGetAccount
func NewSlurmdbdGetAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetAccountsRequest generates requests for SlurmdbdGetAccounts
func NewSlurmdbdGetAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdUpdateAccountRequest generates requests for SlurmdbdUpdateAccount
func NewSlurmdbdUpdateAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDeleteAssociationRequest generates requests for SlurmdbdDeleteAssociation
func NewSlurmdbdDeleteAssociationRequest(server string, params *SlurmdbdDeleteAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/association")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, params.Account); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetAssociationRequest generates requests for SlurmdbdGetAssociation
func NewSlurmdbdGetAssociationRequest(server string, params *SlurmdbdGetAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/association")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetAssociationsRequest generates requests for SlurmdbdGetAssociations
func NewSlurmdbdGetAssociationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/associations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdUpdateAssociationsRequest generates requests for SlurmdbdUpdateAssociations
func NewSlurmdbdUpdateAssociationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/associations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDeleteClusterRequest generates requests for SlurmdbdDeleteCluster
func NewSlurmdbdDeleteClusterRequest(server string, clusterName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetClusterRequest generates requests for SlurmdbdGetCluster
func NewSlurmdbdGetClusterRequest(server string, clusterName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetClustersRequest generates requests for SlurmdbdGetClusters
func NewSlurmdbdGetClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdAddClustersRequest generates requests for SlurmdbdAddClusters
func NewSlurmdbdAddClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetDbConfigRequest generates requests for SlurmdbdGetDbConfig
func NewSlurmdbdGetDbConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdSetDbConfigRequest generates requests for SlurmdbdSetDbConfig
func NewSlurmdbdSetDbConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDiagRequest generates requests for SlurmdbdDiag
func NewSlurmdbdDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/diag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetJobRequest generates requests for SlurmdbdGetJob
func NewSlurmdbdGetJobRequest(server string, jobId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("label", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetJobsRequest generates requests for SlurmdbdGetJobs
func NewSlurmdbdGetJobsRequest(server string, params *SlurmdbdGetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubmitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "submit_time", runtime.ParamLocationQuery, *params.SubmitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Association != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "association", runtime.ParamLocationQuery, *params.Association); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Constraints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "constraints", runtime.ParamLocationQuery, *params.Constraints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpusMax != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cpus_max", runtime.ParamLocationQuery, *params.CpusMax); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpusMin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cpus_min", runtime.ParamLocationQuery, *params.CpusMin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSteps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "skip_steps", runtime.ParamLocationQuery, *params.SkipSteps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWaitForResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_wait_for_result", runtime.ParamLocationQuery, *params.DisableWaitForResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExitCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exit_code", runtime.ParamLocationQuery, *params.ExitCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_name", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodesMax != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nodes_max", runtime.ParamLocationQuery, *params.NodesMax); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodesMin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nodes_min", runtime.ParamLocationQuery, *params.NodesMin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reservation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation", runtime.ParamLocationQuery, *params.Reservation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Step != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Node != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node", runtime.ParamLocationQuery, *params.Node); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wckey", runtime.ParamLocationQuery, *params.Wckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetQosRequest generates requests for SlurmdbdGetQos
func NewSlurmdbdGetQosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/qos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDeleteQosRequest generates requests for SlurmdbdDeleteQos
func NewSlurmdbdDeleteQosRequest(server string, qosName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos_name", runtime.ParamLocationPath, qosName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetSingleQosRequest generates requests for SlurmdbdGetSingleQos
func NewSlurmdbdGetSingleQosRequest(server string, qosName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos_name", runtime.ParamLocationPath, qosName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetTresRequest generates requests for SlurmdbdGetTres
func NewSlurmdbdGetTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/tres")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdUpdateTresRequest generates requests for SlurmdbdUpdateTres
func NewSlurmdbdUpdateTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/tres")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDeleteUserRequest generates requests for SlurmdbdDeleteUser
func NewSlurmdbdDeleteUserRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetUserRequest generates requests for SlurmdbdGetUser
func NewSlurmdbdGetUserRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetUsersRequest generates requests for SlurmdbdGetUsers
func NewSlurmdbdGetUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdUpdateUsersRequest generates requests for SlurmdbdUpdateUsers
func NewSlurmdbdUpdateUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdDeleteWckeyRequest generates requests for SlurmdbdDeleteWckey
func NewSlurmdbdDeleteWckeyRequest(server string, wckey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wckey", runtime.ParamLocationPath, wckey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetWckeyRequest generates requests for SlurmdbdGetWckey
func NewSlurmdbdGetWckeyRequest(server string, wckey string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wckey", runtime.ParamLocationPath, wckey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdGetWckeysRequest generates requests for SlurmdbdGetWckeys
func NewSlurmdbdGetWckeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/wckeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbdAddWckeysRequest generates requests for SlurmdbdAddWckeys
func NewSlurmdbdAddWckeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.37/wckeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenapiV3WithResponse request
	GetOpenapiV3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiV3Response, error)

	// SlurmctldDiagWithResponse request
	SlurmctldDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmctldDiagResponse, error)

	// SlurmctldSubmitJobWithBodyWithResponse request with any body
	SlurmctldSubmitJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmctldSubmitJobResponse, error)

	SlurmctldSubmitJobWithResponse(ctx context.Context, body SlurmctldSubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmctldSubmitJobResponse, error)

	// SlurmctldCancelJobWithResponse request
	SlurmctldCancelJobWithResponse(ctx context.Context, jobId string, params *SlurmctldCancelJobParams, reqEditors ...RequestEditorFn) (*SlurmctldCancelJobResponse, error)

	// SlurmctldGetJobWithResponse request
	SlurmctldGetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmctldGetJobResponse, error)

	// SlurmctldUpdateJobWithBodyWithResponse request with any body
	SlurmctldUpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmctldUpdateJobResponse, error)

	SlurmctldUpdateJobWithResponse(ctx context.Context, jobId string, body SlurmctldUpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmctldUpdateJobResponse, error)

	// SlurmctldGetJobsWithResponse request
	SlurmctldGetJobsWithResponse(ctx context.Context, params *SlurmctldGetJobsParams, reqEditors ...RequestEditorFn) (*SlurmctldGetJobsResponse, error)

	// SlurmctldGetNodeWithResponse request
	SlurmctldGetNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmctldGetNodeResponse, error)

	// SlurmctldGetNodesWithResponse request
	SlurmctldGetNodesWithResponse(ctx context.Context, params *SlurmctldGetNodesParams, reqEditors ...RequestEditorFn) (*SlurmctldGetNodesResponse, error)

	// SlurmctldGetPartitionWithResponse request
	SlurmctldGetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmctldGetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmctldGetPartitionResponse, error)

	// SlurmctldGetPartitionsWithResponse request
	SlurmctldGetPartitionsWithResponse(ctx context.Context, params *SlurmctldGetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmctldGetPartitionsResponse, error)

	// SlurmctldPingWithResponse request
	SlurmctldPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmctldPingResponse, error)

	// SlurmctldGetReservationWithResponse request
	SlurmctldGetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmctldGetReservationParams, reqEditors ...RequestEditorFn) (*SlurmctldGetReservationResponse, error)

	// SlurmctldGetReservationsWithResponse request
	SlurmctldGetReservationsWithResponse(ctx context.Context, params *SlurmctldGetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmctldGetReservationsResponse, error)

	// SlurmdbdDeleteAccountWithResponse request
	SlurmdbdDeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteAccountResponse, error)

	// SlurmdbdGetAccountWithResponse request
	SlurmdbdGetAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetAccountResponse, error)

	// SlurmdbdGetAccountsWithResponse request
	SlurmdbdGetAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetAccountsResponse, error)

	// SlurmdbdUpdateAccountWithResponse request
	SlurmdbdUpdateAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateAccountResponse, error)

	// SlurmdbdDeleteAssociationWithResponse request
	SlurmdbdDeleteAssociationWithResponse(ctx context.Context, params *SlurmdbdDeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteAssociationResponse, error)

	// SlurmdbdGetAssociationWithResponse request
	SlurmdbdGetAssociationWithResponse(ctx context.Context, params *SlurmdbdGetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbdGetAssociationResponse, error)

	// SlurmdbdGetAssociationsWithResponse request
	SlurmdbdGetAssociationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetAssociationsResponse, error)

	// SlurmdbdUpdateAssociationsWithResponse request
	SlurmdbdUpdateAssociationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateAssociationsResponse, error)

	// SlurmdbdDeleteClusterWithResponse request
	SlurmdbdDeleteClusterWithResponse(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteClusterResponse, error)

	// SlurmdbdGetClusterWithResponse request
	SlurmdbdGetClusterWithResponse(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetClusterResponse, error)

	// SlurmdbdGetClustersWithResponse request
	SlurmdbdGetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetClustersResponse, error)

	// SlurmdbdAddClustersWithResponse request
	SlurmdbdAddClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdAddClustersResponse, error)

	// SlurmdbdGetDbConfigWithResponse request
	SlurmdbdGetDbConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetDbConfigResponse, error)

	// SlurmdbdSetDbConfigWithResponse request
	SlurmdbdSetDbConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdSetDbConfigResponse, error)

	// SlurmdbdDiagWithResponse request
	SlurmdbdDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdDiagResponse, error)

	// SlurmdbdGetJobWithResponse request
	SlurmdbdGetJobWithResponse(ctx context.Context, jobId int64, reqEditors ...RequestEditorFn) (*SlurmdbdGetJobResponse, error)

	// SlurmdbdGetJobsWithResponse request
	SlurmdbdGetJobsWithResponse(ctx context.Context, params *SlurmdbdGetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbdGetJobsResponse, error)

	// SlurmdbdGetQosWithResponse request
	SlurmdbdGetQosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetQosResponse, error)

	// SlurmdbdDeleteQosWithResponse request
	SlurmdbdDeleteQosWithResponse(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteQosResponse, error)

	// SlurmdbdGetSingleQosWithResponse request
	SlurmdbdGetSingleQosWithResponse(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetSingleQosResponse, error)

	// SlurmdbdGetTresWithResponse request
	SlurmdbdGetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetTresResponse, error)

	// SlurmdbdUpdateTresWithResponse request
	SlurmdbdUpdateTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateTresResponse, error)

	// SlurmdbdDeleteUserWithResponse request
	SlurmdbdDeleteUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteUserResponse, error)

	// SlurmdbdGetUserWithResponse request
	SlurmdbdGetUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetUserResponse, error)

	// SlurmdbdGetUsersWithResponse request
	SlurmdbdGetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetUsersResponse, error)

	// SlurmdbdUpdateUsersWithResponse request
	SlurmdbdUpdateUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateUsersResponse, error)

	// SlurmdbdDeleteWckeyWithResponse request
	SlurmdbdDeleteWckeyWithResponse(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteWckeyResponse, error)

	// SlurmdbdGetWckeyWithResponse request
	SlurmdbdGetWckeyWithResponse(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*SlurmdbdGetWckeyResponse, error)

	// SlurmdbdGetWckeysWithResponse request
	SlurmdbdGetWckeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetWckeysResponse, error)

	// SlurmdbdAddWckeysWithResponse request
	SlurmdbdAddWckeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdAddWckeysResponse, error)
}

type GetOpenapiV3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiV3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiV3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037Diag
	YAML200      *V0037Diag
}

// Status returns HTTPResponse.Status
func (r SlurmctldDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldSubmitJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037JobSubmissionResponse
	YAML200      *V0037JobSubmissionResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldSubmitJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldSubmitJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldCancelJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SlurmctldCancelJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldCancelJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037JobsResponse
	YAML200      *V0037JobsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldUpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SlurmctldUpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldUpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037JobsResponse
	YAML200      *V0037JobsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037NodesResponse
	YAML200      *V0037NodesResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037NodesResponse
	YAML200      *V0037NodesResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037PartitionsResponse
	YAML200      *V0037PartitionsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037PartitionsResponse
	YAML200      *V0037PartitionsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037Pings
	YAML200      *V0037Pings
}

// Status returns HTTPResponse.Status
func (r SlurmctldPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037ReservationsResponse
	YAML200      *V0037ReservationsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmctldGetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0037ReservationsResponse
	YAML200      *V0037ReservationsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmctldGetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmctldGetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseAccountDelete
	YAML200      *Dbv0037ResponseAccountDelete
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037AccountInfo
	YAML200      *Dbv0037AccountInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037AccountInfo
	YAML200      *Dbv0037AccountInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdUpdateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037AccountResponse
	YAML200      *Dbv0037AccountResponse
}

// Status returns HTTPResponse.Status
func (r SlurmdbdUpdateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdUpdateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDeleteAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseAssociationDelete
	YAML200      *Dbv0037ResponseAssociationDelete
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDeleteAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDeleteAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037AssociationsInfo
	YAML200      *Dbv0037AssociationsInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037AssociationsInfo
	YAML200      *Dbv0037AssociationsInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdUpdateAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseAssociations
	YAML200      *Dbv0037ResponseAssociations
}

// Status returns HTTPResponse.Status
func (r SlurmdbdUpdateAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdUpdateAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseClusterDelete
	YAML200      *Dbv0037ResponseClusterDelete
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ClusterInfo
	YAML200      *Dbv0037ClusterInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ClusterInfo
	YAML200      *Dbv0037ClusterInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdAddClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseClusterAdd
	YAML200      *Dbv0037ResponseClusterAdd
}

// Status returns HTTPResponse.Status
func (r SlurmdbdAddClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdAddClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetDbConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ConfigInfo
	YAML200      *Dbv0037ConfigInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetDbConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetDbConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdSetDbConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ConfigResponse
	YAML200      *Dbv0037ConfigResponse
}

// Status returns HTTPResponse.Status
func (r SlurmdbdSetDbConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdSetDbConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037Diag
	YAML200      *Dbv0037Diag
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037JobInfo
	YAML200      *Dbv0037JobInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037JobInfo
	YAML200      *Dbv0037JobInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037QosInfo
	YAML200      *Dbv0037QosInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDeleteQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseQosDelete
	YAML200      *Dbv0037ResponseQosDelete
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDeleteQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDeleteQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037QosInfo
	YAML200      *Dbv0037QosInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037TresInfo
	YAML200      *Dbv0037TresInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdUpdateTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseTres
	YAML200      *Dbv0037ResponseTres
}

// Status returns HTTPResponse.Status
func (r SlurmdbdUpdateTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdUpdateTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseUserDelete
	YAML200      *Dbv0037ResponseUserDelete
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037UserInfo
	YAML200      *Dbv0037UserInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037UserInfo
	YAML200      *Dbv0037UserInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdUpdateUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseUserUpdate
	YAML200      *Dbv0037ResponseUserUpdate
}

// Status returns HTTPResponse.Status
func (r SlurmdbdUpdateUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdUpdateUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdDeleteWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseWckeyDelete
	YAML200      *Dbv0037ResponseWckeyDelete
}

// Status returns HTTPResponse.Status
func (r SlurmdbdDeleteWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdDeleteWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037WckeyInfo
	YAML200      *Dbv0037WckeyInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdGetWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037WckeyInfo
	YAML200      *Dbv0037WckeyInfo
}

// Status returns HTTPResponse.Status
func (r SlurmdbdGetWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdGetWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbdAddWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dbv0037ResponseWckeyAdd
	YAML200      *Dbv0037ResponseWckeyAdd
}

// Status returns HTTPResponse.Status
func (r SlurmdbdAddWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbdAddWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenapiV3WithResponse request returning *GetOpenapiV3Response
func (c *ClientWithResponses) GetOpenapiV3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiV3Response, error) {
	rsp, err := c.GetOpenapiV3(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiV3Response(rsp)
}

// SlurmctldDiagWithResponse request returning *SlurmctldDiagResponse
func (c *ClientWithResponses) SlurmctldDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmctldDiagResponse, error) {
	rsp, err := c.SlurmctldDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldDiagResponse(rsp)
}

// SlurmctldSubmitJobWithBodyWithResponse request with arbitrary body returning *SlurmctldSubmitJobResponse
func (c *ClientWithResponses) SlurmctldSubmitJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmctldSubmitJobResponse, error) {
	rsp, err := c.SlurmctldSubmitJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldSubmitJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmctldSubmitJobWithResponse(ctx context.Context, body SlurmctldSubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmctldSubmitJobResponse, error) {
	rsp, err := c.SlurmctldSubmitJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldSubmitJobResponse(rsp)
}

// SlurmctldCancelJobWithResponse request returning *SlurmctldCancelJobResponse
func (c *ClientWithResponses) SlurmctldCancelJobWithResponse(ctx context.Context, jobId string, params *SlurmctldCancelJobParams, reqEditors ...RequestEditorFn) (*SlurmctldCancelJobResponse, error) {
	rsp, err := c.SlurmctldCancelJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldCancelJobResponse(rsp)
}

// SlurmctldGetJobWithResponse request returning *SlurmctldGetJobResponse
func (c *ClientWithResponses) SlurmctldGetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmctldGetJobResponse, error) {
	rsp, err := c.SlurmctldGetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetJobResponse(rsp)
}

// SlurmctldUpdateJobWithBodyWithResponse request with arbitrary body returning *SlurmctldUpdateJobResponse
func (c *ClientWithResponses) SlurmctldUpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmctldUpdateJobResponse, error) {
	rsp, err := c.SlurmctldUpdateJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmctldUpdateJobWithResponse(ctx context.Context, jobId string, body SlurmctldUpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmctldUpdateJobResponse, error) {
	rsp, err := c.SlurmctldUpdateJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldUpdateJobResponse(rsp)
}

// SlurmctldGetJobsWithResponse request returning *SlurmctldGetJobsResponse
func (c *ClientWithResponses) SlurmctldGetJobsWithResponse(ctx context.Context, params *SlurmctldGetJobsParams, reqEditors ...RequestEditorFn) (*SlurmctldGetJobsResponse, error) {
	rsp, err := c.SlurmctldGetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetJobsResponse(rsp)
}

// SlurmctldGetNodeWithResponse request returning *SlurmctldGetNodeResponse
func (c *ClientWithResponses) SlurmctldGetNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmctldGetNodeResponse, error) {
	rsp, err := c.SlurmctldGetNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetNodeResponse(rsp)
}

// SlurmctldGetNodesWithResponse request returning *SlurmctldGetNodesResponse
func (c *ClientWithResponses) SlurmctldGetNodesWithResponse(ctx context.Context, params *SlurmctldGetNodesParams, reqEditors ...RequestEditorFn) (*SlurmctldGetNodesResponse, error) {
	rsp, err := c.SlurmctldGetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetNodesResponse(rsp)
}

// SlurmctldGetPartitionWithResponse request returning *SlurmctldGetPartitionResponse
func (c *ClientWithResponses) SlurmctldGetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmctldGetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmctldGetPartitionResponse, error) {
	rsp, err := c.SlurmctldGetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetPartitionResponse(rsp)
}

// SlurmctldGetPartitionsWithResponse request returning *SlurmctldGetPartitionsResponse
func (c *ClientWithResponses) SlurmctldGetPartitionsWithResponse(ctx context.Context, params *SlurmctldGetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmctldGetPartitionsResponse, error) {
	rsp, err := c.SlurmctldGetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetPartitionsResponse(rsp)
}

// SlurmctldPingWithResponse request returning *SlurmctldPingResponse
func (c *ClientWithResponses) SlurmctldPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmctldPingResponse, error) {
	rsp, err := c.SlurmctldPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldPingResponse(rsp)
}

// SlurmctldGetReservationWithResponse request returning *SlurmctldGetReservationResponse
func (c *ClientWithResponses) SlurmctldGetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmctldGetReservationParams, reqEditors ...RequestEditorFn) (*SlurmctldGetReservationResponse, error) {
	rsp, err := c.SlurmctldGetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetReservationResponse(rsp)
}

// SlurmctldGetReservationsWithResponse request returning *SlurmctldGetReservationsResponse
func (c *ClientWithResponses) SlurmctldGetReservationsWithResponse(ctx context.Context, params *SlurmctldGetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmctldGetReservationsResponse, error) {
	rsp, err := c.SlurmctldGetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmctldGetReservationsResponse(rsp)
}

// SlurmdbdDeleteAccountWithResponse request returning *SlurmdbdDeleteAccountResponse
func (c *ClientWithResponses) SlurmdbdDeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteAccountResponse, error) {
	rsp, err := c.SlurmdbdDeleteAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDeleteAccountResponse(rsp)
}

// SlurmdbdGetAccountWithResponse request returning *SlurmdbdGetAccountResponse
func (c *ClientWithResponses) SlurmdbdGetAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetAccountResponse, error) {
	rsp, err := c.SlurmdbdGetAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetAccountResponse(rsp)
}

// SlurmdbdGetAccountsWithResponse request returning *SlurmdbdGetAccountsResponse
func (c *ClientWithResponses) SlurmdbdGetAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetAccountsResponse, error) {
	rsp, err := c.SlurmdbdGetAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetAccountsResponse(rsp)
}

// SlurmdbdUpdateAccountWithResponse request returning *SlurmdbdUpdateAccountResponse
func (c *ClientWithResponses) SlurmdbdUpdateAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateAccountResponse, error) {
	rsp, err := c.SlurmdbdUpdateAccount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdUpdateAccountResponse(rsp)
}

// SlurmdbdDeleteAssociationWithResponse request returning *SlurmdbdDeleteAssociationResponse
func (c *ClientWithResponses) SlurmdbdDeleteAssociationWithResponse(ctx context.Context, params *SlurmdbdDeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteAssociationResponse, error) {
	rsp, err := c.SlurmdbdDeleteAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDeleteAssociationResponse(rsp)
}

// SlurmdbdGetAssociationWithResponse request returning *SlurmdbdGetAssociationResponse
func (c *ClientWithResponses) SlurmdbdGetAssociationWithResponse(ctx context.Context, params *SlurmdbdGetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbdGetAssociationResponse, error) {
	rsp, err := c.SlurmdbdGetAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetAssociationResponse(rsp)
}

// SlurmdbdGetAssociationsWithResponse request returning *SlurmdbdGetAssociationsResponse
func (c *ClientWithResponses) SlurmdbdGetAssociationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetAssociationsResponse, error) {
	rsp, err := c.SlurmdbdGetAssociations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetAssociationsResponse(rsp)
}

// SlurmdbdUpdateAssociationsWithResponse request returning *SlurmdbdUpdateAssociationsResponse
func (c *ClientWithResponses) SlurmdbdUpdateAssociationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateAssociationsResponse, error) {
	rsp, err := c.SlurmdbdUpdateAssociations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdUpdateAssociationsResponse(rsp)
}

// SlurmdbdDeleteClusterWithResponse request returning *SlurmdbdDeleteClusterResponse
func (c *ClientWithResponses) SlurmdbdDeleteClusterWithResponse(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteClusterResponse, error) {
	rsp, err := c.SlurmdbdDeleteCluster(ctx, clusterName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDeleteClusterResponse(rsp)
}

// SlurmdbdGetClusterWithResponse request returning *SlurmdbdGetClusterResponse
func (c *ClientWithResponses) SlurmdbdGetClusterWithResponse(ctx context.Context, clusterName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetClusterResponse, error) {
	rsp, err := c.SlurmdbdGetCluster(ctx, clusterName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetClusterResponse(rsp)
}

// SlurmdbdGetClustersWithResponse request returning *SlurmdbdGetClustersResponse
func (c *ClientWithResponses) SlurmdbdGetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetClustersResponse, error) {
	rsp, err := c.SlurmdbdGetClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetClustersResponse(rsp)
}

// SlurmdbdAddClustersWithResponse request returning *SlurmdbdAddClustersResponse
func (c *ClientWithResponses) SlurmdbdAddClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdAddClustersResponse, error) {
	rsp, err := c.SlurmdbdAddClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdAddClustersResponse(rsp)
}

// SlurmdbdGetDbConfigWithResponse request returning *SlurmdbdGetDbConfigResponse
func (c *ClientWithResponses) SlurmdbdGetDbConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetDbConfigResponse, error) {
	rsp, err := c.SlurmdbdGetDbConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetDbConfigResponse(rsp)
}

// SlurmdbdSetDbConfigWithResponse request returning *SlurmdbdSetDbConfigResponse
func (c *ClientWithResponses) SlurmdbdSetDbConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdSetDbConfigResponse, error) {
	rsp, err := c.SlurmdbdSetDbConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdSetDbConfigResponse(rsp)
}

// SlurmdbdDiagWithResponse request returning *SlurmdbdDiagResponse
func (c *ClientWithResponses) SlurmdbdDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdDiagResponse, error) {
	rsp, err := c.SlurmdbdDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDiagResponse(rsp)
}

// SlurmdbdGetJobWithResponse request returning *SlurmdbdGetJobResponse
func (c *ClientWithResponses) SlurmdbdGetJobWithResponse(ctx context.Context, jobId int64, reqEditors ...RequestEditorFn) (*SlurmdbdGetJobResponse, error) {
	rsp, err := c.SlurmdbdGetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetJobResponse(rsp)
}

// SlurmdbdGetJobsWithResponse request returning *SlurmdbdGetJobsResponse
func (c *ClientWithResponses) SlurmdbdGetJobsWithResponse(ctx context.Context, params *SlurmdbdGetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbdGetJobsResponse, error) {
	rsp, err := c.SlurmdbdGetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetJobsResponse(rsp)
}

// SlurmdbdGetQosWithResponse request returning *SlurmdbdGetQosResponse
func (c *ClientWithResponses) SlurmdbdGetQosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetQosResponse, error) {
	rsp, err := c.SlurmdbdGetQos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetQosResponse(rsp)
}

// SlurmdbdDeleteQosWithResponse request returning *SlurmdbdDeleteQosResponse
func (c *ClientWithResponses) SlurmdbdDeleteQosWithResponse(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteQosResponse, error) {
	rsp, err := c.SlurmdbdDeleteQos(ctx, qosName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDeleteQosResponse(rsp)
}

// SlurmdbdGetSingleQosWithResponse request returning *SlurmdbdGetSingleQosResponse
func (c *ClientWithResponses) SlurmdbdGetSingleQosWithResponse(ctx context.Context, qosName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetSingleQosResponse, error) {
	rsp, err := c.SlurmdbdGetSingleQos(ctx, qosName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetSingleQosResponse(rsp)
}

// SlurmdbdGetTresWithResponse request returning *SlurmdbdGetTresResponse
func (c *ClientWithResponses) SlurmdbdGetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetTresResponse, error) {
	rsp, err := c.SlurmdbdGetTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetTresResponse(rsp)
}

// SlurmdbdUpdateTresWithResponse request returning *SlurmdbdUpdateTresResponse
func (c *ClientWithResponses) SlurmdbdUpdateTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateTresResponse, error) {
	rsp, err := c.SlurmdbdUpdateTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdUpdateTresResponse(rsp)
}

// SlurmdbdDeleteUserWithResponse request returning *SlurmdbdDeleteUserResponse
func (c *ClientWithResponses) SlurmdbdDeleteUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteUserResponse, error) {
	rsp, err := c.SlurmdbdDeleteUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDeleteUserResponse(rsp)
}

// SlurmdbdGetUserWithResponse request returning *SlurmdbdGetUserResponse
func (c *ClientWithResponses) SlurmdbdGetUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*SlurmdbdGetUserResponse, error) {
	rsp, err := c.SlurmdbdGetUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetUserResponse(rsp)
}

// SlurmdbdGetUsersWithResponse request returning *SlurmdbdGetUsersResponse
func (c *ClientWithResponses) SlurmdbdGetUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetUsersResponse, error) {
	rsp, err := c.SlurmdbdGetUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetUsersResponse(rsp)
}

// SlurmdbdUpdateUsersWithResponse request returning *SlurmdbdUpdateUsersResponse
func (c *ClientWithResponses) SlurmdbdUpdateUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdUpdateUsersResponse, error) {
	rsp, err := c.SlurmdbdUpdateUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdUpdateUsersResponse(rsp)
}

// SlurmdbdDeleteWckeyWithResponse request returning *SlurmdbdDeleteWckeyResponse
func (c *ClientWithResponses) SlurmdbdDeleteWckeyWithResponse(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*SlurmdbdDeleteWckeyResponse, error) {
	rsp, err := c.SlurmdbdDeleteWckey(ctx, wckey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdDeleteWckeyResponse(rsp)
}

// SlurmdbdGetWckeyWithResponse request returning *SlurmdbdGetWckeyResponse
func (c *ClientWithResponses) SlurmdbdGetWckeyWithResponse(ctx context.Context, wckey string, reqEditors ...RequestEditorFn) (*SlurmdbdGetWckeyResponse, error) {
	rsp, err := c.SlurmdbdGetWckey(ctx, wckey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetWckeyResponse(rsp)
}

// SlurmdbdGetWckeysWithResponse request returning *SlurmdbdGetWckeysResponse
func (c *ClientWithResponses) SlurmdbdGetWckeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdGetWckeysResponse, error) {
	rsp, err := c.SlurmdbdGetWckeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdGetWckeysResponse(rsp)
}

// SlurmdbdAddWckeysWithResponse request returning *SlurmdbdAddWckeysResponse
func (c *ClientWithResponses) SlurmdbdAddWckeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbdAddWckeysResponse, error) {
	rsp, err := c.SlurmdbdAddWckeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbdAddWckeysResponse(rsp)
}

// ParseGetOpenapiV3Response parses an HTTP response from a GetOpenapiV3WithResponse call
func ParseGetOpenapiV3Response(rsp *http.Response) (*GetOpenapiV3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiV3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmctldDiagResponse parses an HTTP response from a SlurmctldDiagWithResponse call
func ParseSlurmctldDiagResponse(rsp *http.Response) (*SlurmctldDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037Diag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037Diag
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldSubmitJobResponse parses an HTTP response from a SlurmctldSubmitJobWithResponse call
func ParseSlurmctldSubmitJobResponse(rsp *http.Response) (*SlurmctldSubmitJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldSubmitJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037JobSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037JobSubmissionResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldCancelJobResponse parses an HTTP response from a SlurmctldCancelJobWithResponse call
func ParseSlurmctldCancelJobResponse(rsp *http.Response) (*SlurmctldCancelJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldCancelJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmctldGetJobResponse parses an HTTP response from a SlurmctldGetJobWithResponse call
func ParseSlurmctldGetJobResponse(rsp *http.Response) (*SlurmctldGetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037JobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037JobsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldUpdateJobResponse parses an HTTP response from a SlurmctldUpdateJobWithResponse call
func ParseSlurmctldUpdateJobResponse(rsp *http.Response) (*SlurmctldUpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldUpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmctldGetJobsResponse parses an HTTP response from a SlurmctldGetJobsWithResponse call
func ParseSlurmctldGetJobsResponse(rsp *http.Response) (*SlurmctldGetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037JobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037JobsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldGetNodeResponse parses an HTTP response from a SlurmctldGetNodeWithResponse call
func ParseSlurmctldGetNodeResponse(rsp *http.Response) (*SlurmctldGetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037NodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037NodesResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldGetNodesResponse parses an HTTP response from a SlurmctldGetNodesWithResponse call
func ParseSlurmctldGetNodesResponse(rsp *http.Response) (*SlurmctldGetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037NodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037NodesResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldGetPartitionResponse parses an HTTP response from a SlurmctldGetPartitionWithResponse call
func ParseSlurmctldGetPartitionResponse(rsp *http.Response) (*SlurmctldGetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037PartitionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037PartitionsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldGetPartitionsResponse parses an HTTP response from a SlurmctldGetPartitionsWithResponse call
func ParseSlurmctldGetPartitionsResponse(rsp *http.Response) (*SlurmctldGetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037PartitionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037PartitionsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldPingResponse parses an HTTP response from a SlurmctldPingWithResponse call
func ParseSlurmctldPingResponse(rsp *http.Response) (*SlurmctldPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037Pings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037Pings
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldGetReservationResponse parses an HTTP response from a SlurmctldGetReservationWithResponse call
func ParseSlurmctldGetReservationResponse(rsp *http.Response) (*SlurmctldGetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037ReservationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037ReservationsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmctldGetReservationsResponse parses an HTTP response from a SlurmctldGetReservationsWithResponse call
func ParseSlurmctldGetReservationsResponse(rsp *http.Response) (*SlurmctldGetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmctldGetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0037ReservationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0037ReservationsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDeleteAccountResponse parses an HTTP response from a SlurmdbdDeleteAccountWithResponse call
func ParseSlurmdbdDeleteAccountResponse(rsp *http.Response) (*SlurmdbdDeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseAccountDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseAccountDelete
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetAccountResponse parses an HTTP response from a SlurmdbdGetAccountWithResponse call
func ParseSlurmdbdGetAccountResponse(rsp *http.Response) (*SlurmdbdGetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037AccountInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037AccountInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetAccountsResponse parses an HTTP response from a SlurmdbdGetAccountsWithResponse call
func ParseSlurmdbdGetAccountsResponse(rsp *http.Response) (*SlurmdbdGetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037AccountInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037AccountInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdUpdateAccountResponse parses an HTTP response from a SlurmdbdUpdateAccountWithResponse call
func ParseSlurmdbdUpdateAccountResponse(rsp *http.Response) (*SlurmdbdUpdateAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdUpdateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037AccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037AccountResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDeleteAssociationResponse parses an HTTP response from a SlurmdbdDeleteAssociationWithResponse call
func ParseSlurmdbdDeleteAssociationResponse(rsp *http.Response) (*SlurmdbdDeleteAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDeleteAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseAssociationDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseAssociationDelete
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetAssociationResponse parses an HTTP response from a SlurmdbdGetAssociationWithResponse call
func ParseSlurmdbdGetAssociationResponse(rsp *http.Response) (*SlurmdbdGetAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037AssociationsInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037AssociationsInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetAssociationsResponse parses an HTTP response from a SlurmdbdGetAssociationsWithResponse call
func ParseSlurmdbdGetAssociationsResponse(rsp *http.Response) (*SlurmdbdGetAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037AssociationsInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037AssociationsInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdUpdateAssociationsResponse parses an HTTP response from a SlurmdbdUpdateAssociationsWithResponse call
func ParseSlurmdbdUpdateAssociationsResponse(rsp *http.Response) (*SlurmdbdUpdateAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdUpdateAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseAssociations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseAssociations
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDeleteClusterResponse parses an HTTP response from a SlurmdbdDeleteClusterWithResponse call
func ParseSlurmdbdDeleteClusterResponse(rsp *http.Response) (*SlurmdbdDeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseClusterDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseClusterDelete
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetClusterResponse parses an HTTP response from a SlurmdbdGetClusterWithResponse call
func ParseSlurmdbdGetClusterResponse(rsp *http.Response) (*SlurmdbdGetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ClusterInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetClustersResponse parses an HTTP response from a SlurmdbdGetClustersWithResponse call
func ParseSlurmdbdGetClustersResponse(rsp *http.Response) (*SlurmdbdGetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ClusterInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdAddClustersResponse parses an HTTP response from a SlurmdbdAddClustersWithResponse call
func ParseSlurmdbdAddClustersResponse(rsp *http.Response) (*SlurmdbdAddClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdAddClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseClusterAdd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseClusterAdd
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetDbConfigResponse parses an HTTP response from a SlurmdbdGetDbConfigWithResponse call
func ParseSlurmdbdGetDbConfigResponse(rsp *http.Response) (*SlurmdbdGetDbConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetDbConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ConfigInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ConfigInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdSetDbConfigResponse parses an HTTP response from a SlurmdbdSetDbConfigWithResponse call
func ParseSlurmdbdSetDbConfigResponse(rsp *http.Response) (*SlurmdbdSetDbConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdSetDbConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ConfigResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDiagResponse parses an HTTP response from a SlurmdbdDiagWithResponse call
func ParseSlurmdbdDiagResponse(rsp *http.Response) (*SlurmdbdDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037Diag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037Diag
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetJobResponse parses an HTTP response from a SlurmdbdGetJobWithResponse call
func ParseSlurmdbdGetJobResponse(rsp *http.Response) (*SlurmdbdGetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037JobInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037JobInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetJobsResponse parses an HTTP response from a SlurmdbdGetJobsWithResponse call
func ParseSlurmdbdGetJobsResponse(rsp *http.Response) (*SlurmdbdGetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037JobInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037JobInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetQosResponse parses an HTTP response from a SlurmdbdGetQosWithResponse call
func ParseSlurmdbdGetQosResponse(rsp *http.Response) (*SlurmdbdGetQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037QosInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037QosInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDeleteQosResponse parses an HTTP response from a SlurmdbdDeleteQosWithResponse call
func ParseSlurmdbdDeleteQosResponse(rsp *http.Response) (*SlurmdbdDeleteQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDeleteQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseQosDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseQosDelete
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetSingleQosResponse parses an HTTP response from a SlurmdbdGetSingleQosWithResponse call
func ParseSlurmdbdGetSingleQosResponse(rsp *http.Response) (*SlurmdbdGetSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037QosInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037QosInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetTresResponse parses an HTTP response from a SlurmdbdGetTresWithResponse call
func ParseSlurmdbdGetTresResponse(rsp *http.Response) (*SlurmdbdGetTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037TresInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037TresInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdUpdateTresResponse parses an HTTP response from a SlurmdbdUpdateTresWithResponse call
func ParseSlurmdbdUpdateTresResponse(rsp *http.Response) (*SlurmdbdUpdateTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdUpdateTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseTres
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseTres
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDeleteUserResponse parses an HTTP response from a SlurmdbdDeleteUserWithResponse call
func ParseSlurmdbdDeleteUserResponse(rsp *http.Response) (*SlurmdbdDeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseUserDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseUserDelete
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetUserResponse parses an HTTP response from a SlurmdbdGetUserWithResponse call
func ParseSlurmdbdGetUserResponse(rsp *http.Response) (*SlurmdbdGetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037UserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037UserInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetUsersResponse parses an HTTP response from a SlurmdbdGetUsersWithResponse call
func ParseSlurmdbdGetUsersResponse(rsp *http.Response) (*SlurmdbdGetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037UserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037UserInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdUpdateUsersResponse parses an HTTP response from a SlurmdbdUpdateUsersWithResponse call
func ParseSlurmdbdUpdateUsersResponse(rsp *http.Response) (*SlurmdbdUpdateUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdUpdateUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseUserUpdate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseUserUpdate
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdDeleteWckeyResponse parses an HTTP response from a SlurmdbdDeleteWckeyWithResponse call
func ParseSlurmdbdDeleteWckeyResponse(rsp *http.Response) (*SlurmdbdDeleteWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdDeleteWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseWckeyDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseWckeyDelete
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetWckeyResponse parses an HTTP response from a SlurmdbdGetWckeyWithResponse call
func ParseSlurmdbdGetWckeyResponse(rsp *http.Response) (*SlurmdbdGetWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037WckeyInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037WckeyInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdGetWckeysResponse parses an HTTP response from a SlurmdbdGetWckeysWithResponse call
func ParseSlurmdbdGetWckeysResponse(rsp *http.Response) (*SlurmdbdGetWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdGetWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037WckeyInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037WckeyInfo
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmdbdAddWckeysResponse parses an HTTP response from a SlurmdbdAddWckeysWithResponse call
func ParseSlurmdbdAddWckeysResponse(rsp *http.Response) (*SlurmdbdAddWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbdAddWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseWckeyAdd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest Dbv0037ResponseWckeyAdd
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}
